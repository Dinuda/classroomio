import {
  require_dayjs_min
} from "./chunk-TEM7LSAW.js";
import {
  spring
} from "./chunk-JFUN7KAB.js";
import {
  derived,
  readable,
  writable
} from "./chunk-TWEDYX3X.js";
import {
  crossfade,
  fade,
  fly,
  scale
} from "./chunk-LZTYJ3MK.js";
import {
  cubicInOut,
  quintOut
} from "./chunk-PBKF7NME.js";
import "./chunk-C6APWDKU.js";
import "./chunk-WTU6VP2M.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  outro_and_destroy_block,
  prevent_default,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_style,
  space,
  stop_propagation,
  subscribe,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-KERHPXK5.js";
import "./chunk-DMI3OY3J.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-USJHI7ER.js";

// ../../node_modules/.pnpm/just-throttle@2.3.1/node_modules/just-throttle/index.js
var require_just_throttle = __commonJS({
  "../../node_modules/.pnpm/just-throttle@2.3.1/node_modules/just-throttle/index.js"(exports, module) {
    module.exports = throttle2;
    function throttle2(fn, interval, options) {
      var timeoutId = null;
      var throttledFn = null;
      var leading = options && options.leading;
      var trailing = options && options.trailing;
      if (leading == null) {
        leading = true;
      }
      if (trailing == null) {
        trailing = !leading;
      }
      if (leading == true) {
        trailing = false;
      }
      var cancel = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      var flush = function() {
        var call = throttledFn;
        cancel();
        if (call) {
          call();
        }
      };
      var throttleWrapper = function() {
        var callNow = leading && !timeoutId;
        var context = this;
        var args = arguments;
        throttledFn = function() {
          return fn.apply(context, args);
        };
        if (!timeoutId) {
          timeoutId = setTimeout(function() {
            timeoutId = null;
            if (trailing) {
              return throttledFn();
            }
          }, interval);
        }
        if (callNow) {
          callNow = false;
          return throttledFn();
        }
      };
      throttleWrapper.cancel = cancel;
      throttleWrapper.flush = flush;
      return throttleWrapper;
    }
  }
});

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/Datepicker.svelte
var import_dayjs6 = __toESM(require_dayjs_min());

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/stores/datepicker.js
var import_dayjs = __toESM(require_dayjs_min(), 1);
var PICKER_TYPES = ["days", "months", "years"];
var updateSelected = (value, property) => (state) => {
  const newState = { ...state, [property]: value };
  return { ...newState, selected: new Date(newState.year, newState.month, newState.day) };
};
var pipe = (...fns) => (val) => fns.reduce((accum, fn) => fn(accum), val);
var zeroDay = (date) => (0, import_dayjs.default)(date).startOf("day").toDate();
var get = ({ selected, start, end, startOfWeekIndex = 0, shouldEnlargeDay = false }) => {
  const { subscribe: subscribe2, set, update } = writable({
    open: false,
    hasChosen: false,
    selected,
    start: zeroDay(start),
    end: zeroDay(end),
    shouldEnlargeDay,
    enlargeDay: false,
    year: selected.getFullYear(),
    month: selected.getMonth(),
    day: selected.getDate(),
    activeView: "days",
    activeViewDirection: 1,
    startOfWeekIndex
  });
  return {
    set,
    subscribe: subscribe2,
    getState() {
      return get_store_value({ subscribe: subscribe2 });
    },
    enlargeDay(enlargeDay = true) {
      update((state) => ({ ...state, enlargeDay }));
    },
    getSelectableVector(date) {
      const { start: start2, end: end2 } = this.getState();
      if (date < start2)
        return -1;
      if (date > end2)
        return 1;
      return 0;
    },
    isSelectable(date, clamping = []) {
      const vector = this.getSelectableVector(date);
      if (vector === 0)
        return true;
      if (!clamping.length)
        return false;
      const clamped = this.clampValue((0, import_dayjs.default)(date), clamping).toDate();
      return this.isSelectable(clamped);
    },
    clampValue(day, clampable) {
      const vector = this.getSelectableVector(day.toDate());
      if (vector === 0)
        return day;
      const boundaryKey = vector === 1 ? "end" : "start";
      const boundary = (0, import_dayjs.default)(this.getState()[boundaryKey]);
      return clampable.reduce((day2, type) => day2[type](boundary[type]()), day);
    },
    add(amount, unit, clampable = []) {
      update(({ month, year, day, ...state }) => {
        const d = this.clampValue((0, import_dayjs.default)(new Date(year, month, day)).add(amount, unit), clampable);
        if (!this.isSelectable(d.toDate()))
          return { ...state, year, month, day };
        return {
          ...state,
          month: d.month(),
          year: d.year(),
          day: d.date(),
          selected: d.toDate()
        };
      });
    },
    setActiveView(newActiveView) {
      const newIndex = PICKER_TYPES.indexOf(newActiveView);
      if (newIndex === -1)
        return;
      update(({ activeView, ...state }) => ({
        ...state,
        activeViewDirection: PICKER_TYPES.indexOf(activeView) > newIndex ? -1 : 1,
        activeView: newActiveView
      }));
    },
    setYear(year) {
      update(updateSelected(year, "year"));
    },
    setMonth(month) {
      update(updateSelected(month, "month"));
    },
    setDay(day) {
      update(
        pipe(
          updateSelected(day.getDate(), "day"),
          updateSelected(day.getMonth(), "month"),
          updateSelected(day.getFullYear(), "year")
        )
      );
    },
    close(extraState) {
      update((state) => ({ ...state, ...extraState, open: false }));
    },
    selectDay() {
      this.close({ hasChosen: true });
    },
    getCalendarPage(month, year) {
      const { startOfWeekIndex: startOfWeekIndex2 } = this.getState();
      let last = { date: new Date(year, month, 1), outsider: false };
      const days = [];
      while (last.date.getMonth() === month) {
        days.push(last);
        const date = new Date(last.date);
        date.setDate(last.date.getDate() + 1);
        last = { date, outsider: false };
      }
      while (days[0].date.getDay() !== startOfWeekIndex2) {
        const date = new Date(days[0].date);
        date.setDate(days[0].date.getDate() - 1);
        days.unshift({
          date,
          outsider: true
        });
      }
      last.outsider = true;
      while (days.length < 42) {
        days.push(last);
        last = { date: new Date(last.date), outsider: true };
        last.date.setDate(last.date.getDate() + 1);
      }
      return days;
    }
  };
};
var datepicker_default = { get };

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/context.js
var storeContextKey = {};
var keyControlsContextKey = {};
var themeContextKey = {};

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/crossfade/Crossfade.svelte
var get_default_slot_changes = (dirty) => ({ key: dirty & /*key*/
1 });
var get_default_slot_context = (ctx) => ({
  key: (
    /*key*/
    ctx[0]
  ),
  send: (
    /*send*/
    ctx[1]
  ),
  receive: (
    /*receive*/
    ctx[2]
  )
});
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, key*/
        33)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Crossfade", slots, ["default"]);
  let { key = {} } = $$props;
  let { duration: duration2 = (d) => Math.max(150, Math.sqrt(d * 150)) } = $$props;
  let { easing = cubicInOut } = $$props;
  const [send, receive] = crossfade({
    duration: duration2,
    easing,
    fallback(node, params) {
      const style = getComputedStyle(node);
      const transform = style.transform === "none" ? "" : style.transform;
      return {
        duration: duration2,
        easing,
        css: (t) => `
					transform: ${transform} scale(${t});
					opacity: ${t}
				`
      };
    }
  });
  const store = readable({ key, send, receive });
  setContext("crossfade", store);
  const writable_props = ["key", "duration", "easing"];
  Object.keys($$props).forEach((key2) => {
    if (!~writable_props.indexOf(key2) && key2.slice(0, 2) !== "$$" && key2 !== "slot")
      console.warn(`<Crossfade> was created with unknown prop '${key2}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("duration" in $$props2)
      $$invalidate(3, duration2 = $$props2.duration);
    if ("easing" in $$props2)
      $$invalidate(4, easing = $$props2.easing);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    readable,
    crossfade,
    cubicInOut,
    key,
    duration: duration2,
    easing,
    send,
    receive,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("duration" in $$props2)
      $$invalidate(3, duration2 = $$props2.duration);
    if ("easing" in $$props2)
      $$invalidate(4, easing = $$props2.easing);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [key, send, receive, duration2, easing, $$scope, slots];
}
var Crossfade = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { key: 0, duration: 3, easing: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Crossfade",
      options,
      id: create_fragment.name
    });
  }
  get key() {
    throw new Error("<Crossfade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Crossfade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Crossfade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Crossfade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get easing() {
    throw new Error("<Crossfade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set easing(value) {
    throw new Error("<Crossfade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Crossfade_default = Crossfade;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/directives/blurr.js
var blurr_default = (node) => {
  const click = (evt) => {
    if (!node || node.contains(evt.target) || evt.defaultPrevented)
      return;
    node.dispatchEvent(new CustomEvent("blurr", node));
  };
  document.addEventListener("click", click, true);
  return {
    destroy() {
      document.removeEventListener("click", click, true);
    }
  };
};

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/Popover.svelte
var file = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\Popover.svelte";
function add_css(target) {
  append_styles(target, "svelte-ff0ii6", ".trigger.svelte-ff0ii6{display:inline-block}.sc-popover.svelte-ff0ii6{position:relative;display:inline-block}.contents-wrapper.svelte-ff0ii6{transform:translate(-50%, -50%);position:absolute;top:50%;left:50%;z-index:10;overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUG9wb3Zlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUZDLHNCQUFTLENBQ1IsT0FBTyxDQUFFLFlBQ1YsQ0FDQSx5QkFBWSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE9BQU8sQ0FBRSxZQUNWLENBQ0EsK0JBQWtCLENBQ2pCLFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUNoQyxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsR0FBRyxDQUNSLElBQUksQ0FBRSxHQUFHLENBQ1QsT0FBTyxDQUFFLEVBQUUsQ0FDWCxRQUFRLENBQUUsTUFDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQb3BvdmVyLnN2ZWx0ZSJdfQ== */");
}
var get_contents_slot_changes = (dirty) => ({
  key: dirty & /*key*/
  1048576,
  send: dirty & /*send*/
  524288,
  receive: dirty & /*receive*/
  262144
});
var get_contents_slot_context = (ctx) => ({
  key: (
    /*key*/
    ctx[20]
  ),
  send: (
    /*send*/
    ctx[19]
  ),
  receive: (
    /*receive*/
    ctx[18]
  )
});
var get_default_slot_changes2 = (dirty) => ({
  key: dirty & /*key*/
  1048576,
  send: dirty & /*send*/
  524288,
  receive: dirty & /*receive*/
  262144
});
var get_default_slot_context2 = (ctx) => ({
  key: (
    /*key*/
    ctx[20]
  ),
  send: (
    /*send*/
    ctx[19]
  ),
  receive: (
    /*receive*/
    ctx[18]
  )
});
function create_else_block(ctx) {
  let div2;
  let div1;
  let div0;
  let current;
  const contents_slot_template = (
    /*#slots*/
    ctx[10].contents
  );
  const contents_slot = create_slot(
    contents_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_contents_slot_context
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (contents_slot)
        contents_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (contents_slot)
        contents_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "contents-inner");
      add_location(div0, file, 75, 5, 1712);
      attr_dev(div1, "class", "contents");
      add_location(div1, file, 74, 4, 1684);
      attr_dev(div2, "class", "contents-wrapper svelte-ff0ii6");
      set_style(div2, "transform", "translate(-50%,-50%) translate(" + /*translateX*/
      ctx[4] + "px, " + /*translateY*/
      ctx[3] + "px)");
      add_location(div2, file, 69, 3, 1523);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (contents_slot) {
        contents_slot.m(div0, null);
      }
      ctx[12](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (contents_slot) {
        if (contents_slot.p && (!current || dirty & /*$$scope, key, send, receive*/
        1851392)) {
          update_slot_base(
            contents_slot,
            contents_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              contents_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_contents_slot_changes
            ),
            get_contents_slot_context
          );
        }
      }
      if (!current || dirty & /*translateX, translateY*/
      24) {
        set_style(div2, "transform", "translate(-50%,-50%) translate(" + /*translateX*/
        ctx2[4] + "px, " + /*translateY*/
        ctx2[3] + "px)");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(contents_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contents_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (contents_slot)
        contents_slot.d(detaching);
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(69:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let div_resize_listener;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "trigger svelte-ff0ii6");
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[11].call(div)
      ));
      add_location(div, file, 60, 3, 1333);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[11].bind(div)
      );
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*openPopover*/
          ctx[9],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, key, send, receive*/
        1851392)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      div_resize_listener();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(60:2) {#if !isOpen}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_style_value;
  let blurr_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*isOpen*/
    ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "sc-popover svelte-ff0ii6");
      attr_dev(div, "style", div_style_value = /*style*/
      ctx[1] + "; min-width: " + /*triggerWidth*/
      (ctx[6] + 1) + "px; min-height: " + /*triggerHeight*/
      (ctx[7] + 1) + "px;");
      add_location(div, file, 52, 1, 1145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[13](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(blurr_action = blurr_default.call(null, div)),
          listen_dev(
            div,
            "blurr",
            /*close*/
            ctx[2],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*style, triggerWidth, triggerHeight*/
      194 && div_style_value !== (div_style_value = /*style*/
      ctx2[1] + "; min-width: " + /*triggerWidth*/
      (ctx2[6] + 1) + "px; min-height: " + /*triggerHeight*/
      (ctx2[7] + 1) + "px;")) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(52:0) <Crossfade let:receive let:send let:key>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let crossfade2;
  let current;
  crossfade2 = new Crossfade_default({
    props: {
      $$slots: {
        default: [
          create_default_slot,
          ({ receive, send, key }) => ({ 18: receive, 19: send, 20: key }),
          ({ receive, send, key }) => (receive ? 262144 : 0) | (send ? 524288 : 0) | (key ? 1048576 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(crossfade2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(crossfade2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(crossfade2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const crossfade_changes = {};
      if (dirty & /*$$scope, style, triggerWidth, triggerHeight, popover, key, send, receive, isOpen, translateX, translateY, contentsWrapper*/
      1851899) {
        crossfade_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crossfade2.$set(crossfade_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(crossfade2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(crossfade2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(crossfade2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["default", "contents"]);
  let { isOpen = false } = $$props;
  let { style = "" } = $$props;
  let translateY = 0;
  let translateX = 0;
  let popover;
  let triggerWidth;
  let triggerHeight;
  let contentsWrapper;
  const close = () => {
    $$invalidate(0, isOpen = false);
  };
  const getDistanceToEdges = () => {
    let { top, bottom, left, right } = contentsWrapper.getBoundingClientRect();
    return {
      top: top + -1 * translateY,
      bottom: window.innerHeight - bottom + translateY,
      left: left + -1 * translateX,
      right: document.body.clientWidth - right + translateX
    };
  };
  const getY = ({ bottom, top }) => {
    if (top < 0)
      return -1 * top;
    if (bottom < 0)
      return bottom;
    return 0;
  };
  const getX = ({ left, right }) => {
    if (left < 0)
      return -1 * left;
    if (right < 0)
      return right;
    return 0;
  };
  const openPopover = async () => {
    $$invalidate(0, isOpen = true);
    await tick();
    let dist = getDistanceToEdges();
    $$invalidate(4, translateX = getX(dist));
    $$invalidate(3, translateY = getY(dist));
  };
  const writable_props = ["isOpen", "style"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Popover> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    triggerWidth = this.offsetWidth;
    triggerHeight = this.offsetHeight;
    $$invalidate(6, triggerWidth);
    $$invalidate(7, triggerHeight);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentsWrapper = $$value;
      $$invalidate(8, contentsWrapper);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popover = $$value;
      $$invalidate(5, popover);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("isOpen" in $$props2)
      $$invalidate(0, isOpen = $$props2.isOpen);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Crossfade: Crossfade_default,
    blurr: blurr_default,
    tick,
    isOpen,
    style,
    translateY,
    translateX,
    popover,
    triggerWidth,
    triggerHeight,
    contentsWrapper,
    close,
    getDistanceToEdges,
    getY,
    getX,
    openPopover
  });
  $$self.$inject_state = ($$props2) => {
    if ("isOpen" in $$props2)
      $$invalidate(0, isOpen = $$props2.isOpen);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("translateY" in $$props2)
      $$invalidate(3, translateY = $$props2.translateY);
    if ("translateX" in $$props2)
      $$invalidate(4, translateX = $$props2.translateX);
    if ("popover" in $$props2)
      $$invalidate(5, popover = $$props2.popover);
    if ("triggerWidth" in $$props2)
      $$invalidate(6, triggerWidth = $$props2.triggerWidth);
    if ("triggerHeight" in $$props2)
      $$invalidate(7, triggerHeight = $$props2.triggerHeight);
    if ("contentsWrapper" in $$props2)
      $$invalidate(8, contentsWrapper = $$props2.contentsWrapper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    style,
    close,
    translateY,
    translateX,
    popover,
    triggerWidth,
    triggerHeight,
    contentsWrapper,
    openPopover,
    slots,
    div_elementresize_handler,
    div2_binding,
    div_binding,
    $$scope
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { isOpen: 0, style: 1, close: 2 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment2.name
    });
  }
  get isOpen() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    return this.$$.ctx[2];
  }
  set close(value) {
    throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/config/theme.js
var theme_exports = {};
__export(theme_exports, {
  dark: () => dark,
  light: () => light
});
var light = {
  calendar: {
    width: "700px",
    maxWidth: "100vw",
    legend: {
      height: "45px"
    },
    shadow: "0px 10px 26px rgba(0, 0, 0, 0.25)",
    colors: {
      text: {
        primary: "#333",
        highlight: "#fff"
      },
      background: {
        primary: "#fff",
        highlight: "#eb7400",
        hover: "#eee"
      },
      border: "#eee"
    },
    font: {
      regular: "1.5em",
      large: "37em"
    },
    grid: {
      disabledOpacity: ".35",
      outsiderOpacity: ".6"
    }
  }
};
var dark = {
  calendar: {
    width: "700px",
    maxWidth: "100vw",
    legend: {
      height: "45px"
    },
    shadow: "0px 10px 26px rgba(0, 0, 0, 0.25)",
    colors: {
      text: {
        primary: "#eee",
        highlight: "#fff"
      },
      background: {
        primary: "#333",
        highlight: "#5829d6",
        hover: "#222"
      },
      border: "#222"
    },
    font: {
      regular: "1.5em",
      large: "37em"
    },
    grid: {
      disabledOpacity: ".5",
      outsiderOpacity: ".7"
    }
  }
};

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/Theme.svelte
var { Object: Object_1 } = globals;
var get_default_slot_changes3 = (dirty) => ({
  appliedTheme: dirty & /*appliedTheme*/
  1,
  style: dirty & /*style*/
  2
});
var get_default_slot_context3 = (ctx) => ({
  appliedTheme: (
    /*appliedTheme*/
    ctx[0]
  ),
  style: (
    /*style*/
    ctx[1]
  )
});
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, appliedTheme, style*/
        35)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let style;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Theme", slots, ["default"]);
  let { theme = {} } = $$props;
  let { appliedTheme } = $$props;
  let { prefix = "--sc-theme" } = $$props;
  let { defaultTheme = light } = $$props;
  const store = writable();
  setContext(themeContextKey, store);
  const getStyle = (obj) => Object.entries(obj).map(([k, v]) => `${prefix}-${k}: ${v}`).join(";");
  const getTheme = (defaults, overrides = {}, base = "") => Object.entries(defaults).reduce(
    (acc, [k, v]) => {
      if (typeof v === "object")
        return {
          ...acc,
          ...getTheme(v, overrides[k], [base, k].filter(Boolean).join("-"))
        };
      return {
        ...acc,
        [[base, k].filter(Boolean).join("-")]: overrides[k] || v
      };
    },
    {}
  );
  $$self.$$.on_mount.push(function() {
    if (appliedTheme === void 0 && !("appliedTheme" in $$props || $$self.$$.bound[$$self.$$.props["appliedTheme"]])) {
      console.warn("<Theme> was created without expected prop 'appliedTheme'");
    }
  });
  const writable_props = ["theme", "appliedTheme", "prefix", "defaultTheme"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Theme> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("appliedTheme" in $$props2)
      $$invalidate(0, appliedTheme = $$props2.appliedTheme);
    if ("prefix" in $$props2)
      $$invalidate(3, prefix = $$props2.prefix);
    if ("defaultTheme" in $$props2)
      $$invalidate(4, defaultTheme = $$props2.defaultTheme);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    lightTheme: light,
    themeContextKey,
    setContext,
    writable,
    theme,
    appliedTheme,
    prefix,
    defaultTheme,
    store,
    getStyle,
    getTheme,
    style
  });
  $$self.$inject_state = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(2, theme = $$props2.theme);
    if ("appliedTheme" in $$props2)
      $$invalidate(0, appliedTheme = $$props2.appliedTheme);
    if ("prefix" in $$props2)
      $$invalidate(3, prefix = $$props2.prefix);
    if ("defaultTheme" in $$props2)
      $$invalidate(4, defaultTheme = $$props2.defaultTheme);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*defaultTheme, theme*/
    20) {
      $:
        $$invalidate(0, appliedTheme = getTheme(defaultTheme, theme));
    }
    if ($$self.$$.dirty & /*appliedTheme*/
    1) {
      $:
        $$invalidate(1, style = getStyle(appliedTheme));
    }
    if ($$self.$$.dirty & /*appliedTheme*/
    1) {
      $:
        store.set(appliedTheme);
    }
  };
  return [appliedTheme, style, theme, prefix, defaultTheme, $$scope, slots];
}
var Theme = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      theme: 2,
      appliedTheme: 0,
      prefix: 3,
      defaultTheme: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Theme",
      options,
      id: create_fragment3.name
    });
  }
  get theme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get appliedTheme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set appliedTheme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultTheme() {
    throw new Error("<Theme>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultTheme(value) {
    throw new Error("<Theme>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Theme_default = Theme;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/config.js
var KEY_CODES = {
  33: "pageUp",
  34: "pageDown",
  37: "left",
  38: "up",
  39: "right",
  40: "down",
  27: "escape",
  13: "enter",
  17: "control"
};

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/KeyControls.svelte
var import_just_throttle = __toESM(require_just_throttle());
function create_fragment4(ctx) {
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          function() {
            if (is_function(
              /*eventHandler*/
              ctx[0]
            ))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let eventHandler;
  let $currentCtx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("KeyControls", slots, ["default"]);
  let { limit = 0 } = $$props;
  let { ctx = null } = $$props;
  const currentCtx = getContext(keyControlsContextKey);
  validate_store(currentCtx, "currentCtx");
  component_subscribe($$self, currentCtx, (value) => $$invalidate(6, $currentCtx = value));
  const key = (evt) => {
    if (ctx && !ctx.includes($currentCtx))
      return;
    const mapping = $$props[KEY_CODES[evt.keyCode]];
    if (mapping)
      mapping();
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("limit" in $$new_props)
      $$invalidate(2, limit = $$new_props.limit);
    if ("ctx" in $$new_props)
      $$invalidate(3, ctx = $$new_props.ctx);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    KEY_CODES,
    keyControlsContextKey,
    throttle: import_just_throttle.default,
    getContext,
    limit,
    ctx,
    currentCtx,
    key,
    eventHandler,
    $currentCtx
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("limit" in $$props)
      $$invalidate(2, limit = $$new_props.limit);
    if ("ctx" in $$props)
      $$invalidate(3, ctx = $$new_props.ctx);
    if ("eventHandler" in $$props)
      $$invalidate(0, eventHandler = $$new_props.eventHandler);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*limit*/
    4) {
      $:
        $$invalidate(0, eventHandler = limit ? (0, import_just_throttle.default)(key, limit) : key);
    }
  };
  $$props = exclude_internal_props($$props);
  return [eventHandler, currentCtx, limit, ctx, $$scope, slots];
}
var KeyControls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { limit: 2, ctx: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "KeyControls",
      options,
      id: create_fragment4.name
    });
  }
  get limit() {
    throw new Error("<KeyControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<KeyControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ctx() {
    throw new Error("<KeyControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ctx(value) {
    throw new Error("<KeyControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var KeyControls_default = KeyControls;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/Grid.svelte
var file2 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\generic\\Grid.svelte";
function add_css2(target) {
  append_styles(target, "svelte-jmgdr0", ".grid.svelte-jmgdr0{display:grid;background:var(--sc-theme-calendar-colors-border);row-gap:1px;column-gap:1px;height:100%}.grid.svelte-jmgdr0>*{font-size:var(--sc-theme-calendar-font-regular);text-decoration:none;color:var(--sc-theme-calendar-colors-text-primary);transition:all 180ms ease-out;background:var(--sc-theme-calendar-colors-background-primary);display:grid;text-align:center;align-items:center}@media(max-width: 720px){.grid.svelte-jmgdr0>*{font-size:calc(var(--sc-theme-calendar-font-regular) * 0.75)}}.grid.svelte-jmgdr0>*:hover{background:var(--sc-theme-calendar-colors-background-hover)}.grid.svelte-jmgdr0>*.selected{background:var(--sc-theme-calendar-colors-background-highlight);color:var(--sc-theme-calendar-colors-text-highlight);opacity:1}.grid.svelte-jmgdr0>*.outsider{opacity:var(--sc-theme-calendar-grid-outsiderOpacity)}.grid.svelte-jmgdr0>*.disabled{opacity:var(--sc-theme-calendar-grid-disabledOpacity)}.grid.svelte-jmgdr0>*.disabled:hover{background:var(--sc-theme-calendar-colors-background-primary);cursor:default}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JpZC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBU0MsbUJBQU0sQ0FDTCxPQUFPLENBQUUsSUFBSSxDQUNiLFVBQVUsQ0FBRSxJQUFJLGlDQUFpQyxDQUFDLENBQ2xELE9BQU8sQ0FBRSxHQUFHLENBQ1osVUFBVSxDQUFFLEdBQUcsQ0FDZixNQUFNLENBQUUsSUFDVCxDQUNBLG1CQUFLLENBQVcsQ0FBRyxDQUNsQixTQUFTLENBQUUsSUFBSSxnQ0FBZ0MsQ0FBQyxDQUNoRCxlQUFlLENBQUUsSUFBSSxDQUNyQixLQUFLLENBQUUsSUFBSSx1Q0FBdUMsQ0FBQyxDQUNuRCxVQUFVLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQzlCLFVBQVUsQ0FBRSxJQUFJLDZDQUE2QyxDQUFDLENBQzlELE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsV0FBVyxDQUFFLE1BQ2QsQ0FFQSxNQUFPLFlBQVksS0FBSyxDQUFFLENBQ3pCLG1CQUFLLENBQVcsQ0FBRyxDQUNsQixTQUFTLENBQUUsS0FBSyxJQUFJLGdDQUFnQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDN0QsQ0FDRCxDQUVBLG1CQUFLLENBQVcsT0FBUyxDQUN4QixVQUFVLENBQUUsSUFBSSwyQ0FBMkMsQ0FDNUQsQ0FDQSxtQkFBSyxDQUFXLFVBQVksQ0FDM0IsVUFBVSxDQUFFLElBQUksK0NBQStDLENBQUMsQ0FDaEUsS0FBSyxDQUFFLElBQUkseUNBQXlDLENBQUMsQ0FDckQsT0FBTyxDQUFFLENBQ1YsQ0FDQSxtQkFBSyxDQUFXLFVBQVksQ0FDM0IsT0FBTyxDQUFFLElBQUksd0NBQXdDLENBQ3RELENBQ0EsbUJBQUssQ0FBVyxVQUFZLENBQzNCLE9BQU8sQ0FBRSxJQUFJLHdDQUF3QyxDQUN0RCxDQUNBLG1CQUFLLENBQVcsZ0JBQWtCLENBQ2pDLFVBQVUsQ0FBRSxJQUFJLDZDQUE2QyxDQUFDLENBQzlELE1BQU0sQ0FBRSxPQUNUIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkdyaWQuc3ZlbHRlIl19 */");
}
function create_fragment5(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "grid svelte-jmgdr0");
      set_style(
        div,
        "grid-template",
        /*template*/
        ctx[0]
      );
      add_location(div, file2, 4, 0, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*template*/
      1) {
        set_style(
          div,
          "grid-template",
          /*template*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { template = "repeat(4, 1fr) / repeat(3, 1fr)" } = $$props;
  const writable_props = ["template"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Grid> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("template" in $$props2)
      $$invalidate(0, template = $$props2.template);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ template });
  $$self.$inject_state = ($$props2) => {
    if ("template" in $$props2)
      $$invalidate(0, template = $$props2.template);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [template, $$scope, slots];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { template: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment5.name
    });
  }
  get template() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set template(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/InfiniteGrid.svelte
var file3 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\generic\\InfiniteGrid.svelte";
function add_css3(target) {
  append_styles(target, "svelte-198r3wi", ".grid.svelte-198r3wi.svelte-198r3wi{overflow:hidden;height:100%;display:grid}.grid.svelte-198r3wi>.svelte-198r3wi{position:absolute;top:0;left:0;right:0;bottom:0;transition-property:none !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5maW5pdGVHcmlkLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFpRkMsbUNBQU0sQ0FDTCxRQUFRLENBQUUsTUFBTSxDQUNoQixNQUFNLENBQUUsSUFBSSxDQUNaLE9BQU8sQ0FBRSxJQUNWLENBQ0Esb0JBQUssQ0FBRyxlQUFFLENBQ1QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixJQUFJLENBQUUsQ0FBQyxDQUNQLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxtQkFBbUIsQ0FBRSxJQUFJLENBQUMsVUFDM0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSW5maW5pdGVHcmlkLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
var get_default_slot_spread_changes = (dirty) => dirty & /*$visibleData*/
16;
var get_default_slot_changes4 = (dirty) => ({ index: dirty & /*$visibleData*/
16 });
var get_default_slot_context4 = (ctx) => ({
  .../*obj*/
  ctx[28].data,
  index: (
    /*obj*/
    ctx[28].index
  )
});
function create_each_block(key_1, ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_default_slot_context4
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "transform", "translateY(" + /*obj*/
      ctx[28].pos + "px)");
      attr_dev(div, "class", "svelte-198r3wi");
      add_location(div, file3, 74, 2, 2276);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $visibleData*/
        1048592)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[20],
            get_default_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[20],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
      if (!current || dirty & /*$visibleData*/
      16) {
        set_style(div, "transform", "translateY(" + /*obj*/
        ctx[28].pos + "px)");
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(74:1) {#each $visibleData as obj (obj.data?.[idKey] || obj.index)}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_resize_listener;
  let current;
  let each_value = ensure_array_like_dev(
    /*$visibleData*/
    ctx[4]
  );
  const get_key = (ctx2) => {
    var _a;
    return (
      /*obj*/
      ((_a = ctx2[28].data) == null ? void 0 : _a[
        /*idKey*/
        ctx2[0]
      ]) || /*obj*/
      ctx2[28].index
    );
  };
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "grid svelte-198r3wi");
      attr_dev(
        div,
        "style",
        /*gridStyle*/
        ctx[3]
      );
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[22].call(div)
      ));
      add_location(div, file3, 72, 0, 2122);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[22].bind(div)
      );
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$visibleData, $$scope, idKey*/
      1048593) {
        each_value = ensure_array_like_dev(
          /*$visibleData*/
          ctx2[4]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty & /*gridStyle*/
      8) {
        attr_dev(
          div,
          "style",
          /*gridStyle*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let type;
  let gridStyle;
  let $initialized;
  let $dim;
  let $offset;
  let $visibleData, $$unsubscribe_visibleData = noop, $$subscribe_visibleData = () => ($$unsubscribe_visibleData(), $$unsubscribe_visibleData = subscribe(visibleData, ($$value) => $$invalidate(4, $visibleData = $$value)), visibleData);
  $$self.$$.on_destroy.push(() => $$unsubscribe_visibleData());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InfiniteGrid", slots, ["default"]);
  let { cellCount: cellCount2 = 4 } = $$props;
  let { itemCount = 0 } = $$props;
  let { index = 0 } = $$props;
  let { vertical = true } = $$props;
  let { get: get2 } = $$props;
  let { stiffness = 0.065 } = $$props;
  let { damping = 0.9 } = $$props;
  let { useCache = true } = $$props;
  let { idKey = void 0 } = $$props;
  const move = (amount) => {
    $$invalidate(8, index = Math.max(0, Math.min(itemCount - 1, index + amount)));
  };
  const forceUpdate = writable(false);
  const triggerUpdate = async () => {
    await tick();
    forceUpdate.set(true);
    await tick();
    forceUpdate.set(false);
  };
  const getCached = (index2) => {
    var _a;
    return ((_a = $visibleData.find(({ index: i }) => i === index2)) == null ? void 0 : _a.data) || get2(index2);
  };
  let inRange = [-Infinity, Infinity];
  const initialized = writable(false);
  validate_store(initialized, "initialized");
  component_subscribe($$self, initialized, (value) => $$invalidate(19, $initialized = value));
  const dim = writable({ w: 0, h: 0 });
  validate_store(dim, "dim");
  component_subscribe($$self, dim, (value) => $$invalidate(2, $dim = value));
  const offset = spring(0, { stiffness, damping });
  validate_store(offset, "offset");
  component_subscribe($$self, offset, (value) => $$invalidate(24, $offset = value));
  const visibleData = derived(
    [dim, offset, initialized, forceUpdate],
    ([{ w, h }, $o, $initialized2, $force]) => {
      if (!w || !h || !$initialized2)
        return [];
      if ($o < inRange[0] || $o > inRange[1])
        return $visibleData;
      const divisibleHeight = cellCount2 > 1 ? h + (cellCount2 - h % cellCount2) : h;
      const cellHeight = h / cellCount2;
      const start = Math.max(-1, Math.floor(-1 * $o / cellHeight) - 1);
      const baseOffset = $o % cellHeight;
      return Array(cellCount2 + 2).fill(0).map((_, i) => {
        const index2 = i + start;
        const pos = baseOffset + (i - 1) * cellHeight;
        if (index2 < 0 || index2 >= itemCount)
          return void 0;
        const data = $force || !useCache ? get2(index2) : getCached(index2);
        return { data, pos, index: index2 };
      }).filter(Boolean);
    },
    []
  );
  validate_store(visibleData, "visibleData");
  $$subscribe_visibleData();
  const updateOffset = (o) => {
    inRange = [o, $offset].sort((a, b) => a - b);
    offset.set(o, { hard: !$initialized });
  };
  $$self.$$.on_mount.push(function() {
    if (get2 === void 0 && !("get" in $$props || $$self.$$.bound[$$self.$$.props["get"]])) {
      console.warn("<InfiniteGrid> was created without expected prop 'get'");
    }
  });
  const writable_props = [
    "cellCount",
    "itemCount",
    "index",
    "vertical",
    "get",
    "stiffness",
    "damping",
    "useCache",
    "idKey"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InfiniteGrid> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    $dim.h = this.clientHeight;
    dim.set($dim);
    $dim.w = this.clientWidth;
    dim.set($dim);
  }
  $$self.$$set = ($$props2) => {
    if ("cellCount" in $$props2)
      $$invalidate(9, cellCount2 = $$props2.cellCount);
    if ("itemCount" in $$props2)
      $$invalidate(10, itemCount = $$props2.itemCount);
    if ("index" in $$props2)
      $$invalidate(8, index = $$props2.index);
    if ("vertical" in $$props2)
      $$invalidate(11, vertical = $$props2.vertical);
    if ("get" in $$props2)
      $$invalidate(12, get2 = $$props2.get);
    if ("stiffness" in $$props2)
      $$invalidate(13, stiffness = $$props2.stiffness);
    if ("damping" in $$props2)
      $$invalidate(14, damping = $$props2.damping);
    if ("useCache" in $$props2)
      $$invalidate(15, useCache = $$props2.useCache);
    if ("idKey" in $$props2)
      $$invalidate(0, idKey = $$props2.idKey);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    tick,
    spring,
    derived,
    writable,
    cellCount: cellCount2,
    itemCount,
    index,
    vertical,
    get: get2,
    stiffness,
    damping,
    useCache,
    idKey,
    move,
    forceUpdate,
    triggerUpdate,
    getCached,
    inRange,
    initialized,
    dim,
    offset,
    visibleData,
    updateOffset,
    type,
    gridStyle,
    $initialized,
    $dim,
    $offset,
    $visibleData
  });
  $$self.$inject_state = ($$props2) => {
    if ("cellCount" in $$props2)
      $$invalidate(9, cellCount2 = $$props2.cellCount);
    if ("itemCount" in $$props2)
      $$invalidate(10, itemCount = $$props2.itemCount);
    if ("index" in $$props2)
      $$invalidate(8, index = $$props2.index);
    if ("vertical" in $$props2)
      $$invalidate(11, vertical = $$props2.vertical);
    if ("get" in $$props2)
      $$invalidate(12, get2 = $$props2.get);
    if ("stiffness" in $$props2)
      $$invalidate(13, stiffness = $$props2.stiffness);
    if ("damping" in $$props2)
      $$invalidate(14, damping = $$props2.damping);
    if ("useCache" in $$props2)
      $$invalidate(15, useCache = $$props2.useCache);
    if ("idKey" in $$props2)
      $$invalidate(0, idKey = $$props2.idKey);
    if ("inRange" in $$props2)
      inRange = $$props2.inRange;
    if ("type" in $$props2)
      $$invalidate(18, type = $$props2.type);
    if ("gridStyle" in $$props2)
      $$invalidate(3, gridStyle = $$props2.gridStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*vertical*/
    2048) {
      $:
        $$invalidate(18, type = vertical ? "rows" : "columns");
    }
    if ($$self.$$.dirty & /*type, cellCount*/
    262656) {
      $:
        $$invalidate(3, gridStyle = `grid-template-${type}: repeat(${cellCount2}, 1fr);`);
    }
    if ($$self.$$.dirty & /*$dim, cellCount, index, $initialized*/
    525060) {
      $: {
        if ($dim.w && $dim.h) {
          updateOffset($dim.h / cellCount2 * index * -1);
          if (!$initialized)
            initialized.set(true);
        }
      }
    }
  };
  return [
    idKey,
    visibleData,
    $dim,
    gridStyle,
    $visibleData,
    initialized,
    dim,
    offset,
    index,
    cellCount2,
    itemCount,
    vertical,
    get2,
    stiffness,
    damping,
    useCache,
    move,
    triggerUpdate,
    type,
    $initialized,
    $$scope,
    slots,
    div_elementresize_handler
  ];
}
var InfiniteGrid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        cellCount: 9,
        itemCount: 10,
        index: 8,
        vertical: 11,
        get: 12,
        stiffness: 13,
        damping: 14,
        useCache: 15,
        idKey: 0,
        move: 16,
        triggerUpdate: 17,
        visibleData: 1
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfiniteGrid",
      options,
      id: create_fragment6.name
    });
  }
  get cellCount() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellCount(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemCount() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemCount(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get index() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get get() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set get(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stiffness() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stiffness(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get damping() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set damping(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useCache() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useCache(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get idKey() {
    throw new Error("<InfiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set idKey(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get move() {
    return this.$$.ctx[16];
  }
  set move(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerUpdate() {
    return this.$$.ctx[17];
  }
  set triggerUpdate(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibleData() {
    return this.$$.ctx[1];
  }
  set visibleData(value) {
    throw new Error("<InfiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InfiniteGrid_default = InfiniteGrid;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/calendar/DayPicker.svelte
var import_dayjs2 = __toESM(require_dayjs_min());

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/config/scroll.js
var scrollStep = 120;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/directives/scrollable.js
var scrollable_default = (node, opts) => {
  let { y: yi = 0, step = scrollStep } = opts;
  let lastTouch = 0;
  let y = yi;
  const updateY = (val) => {
    const { maxSteps = Infinity } = opts;
    y = Math.max(0, Math.min(maxSteps * step, val));
  };
  const emitY = () => {
    if (Math.round(y / step) === Math.round(yi / step))
      return;
    yi = y;
    node.dispatchEvent(
      new CustomEvent("y", {
        detail: {
          y,
          step: Math.round(y / step)
        }
      })
    );
  };
  const wheelListener = ({ deltaY }) => {
    updateY(y + deltaY);
    emitY();
  };
  const touchstartListener = ({ touches: [{ pageY }] }) => {
    lastTouch = pageY;
    emitY();
  };
  const touchmoveListener = ({ touches: [{ pageY }] }) => {
    updateY(y - (pageY - lastTouch));
    lastTouch = pageY;
    emitY();
  };
  node.addEventListener("wheel", wheelListener);
  node.addEventListener("touchstart", touchstartListener);
  node.addEventListener("touchmove", touchmoveListener);
  node.style.touchAction = "none";
  return {
    destroy() {
      node.removeEventListener("wheel", wheelListener);
      node.removeEventListener("touchstart", touchstartListener);
      node.removeEventListener("touchmove", touchmoveListener);
    }
  };
};

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/calendar/DayPicker.svelte
var file4 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\calendar\\DayPicker.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1unzsxu", ".container.svelte-1unzsxu{display:grid;grid-template-rows:auto 1fr}.legend.svelte-1unzsxu{display:grid;grid-template:1fr / repeat(7, 1fr);height:var(--sc-theme-calendar-legend-height);z-index:2;background:var(--sc-theme-calendar-colors-background-primary);border-bottom:1px solid var(--sc-theme-calendar-colors-border);align-items:center}a.svelte-1unzsxu{font-size:1em}.stage.svelte-1unzsxu{display:grid;grid-row:2;grid-column:1}.selected-big.svelte-1unzsxu{color:var(--sc-theme-calendar-colors-background-highlight);background:var(--sc-theme-calendar-colors-background-hover);text-align:center;align-items:center;font-size:var(--sc-theme-calendar-font-large);z-index:2;opacity:1;line-height:0}@media(max-width: 720px){.selected-big.svelte-1unzsxu{font-size:calc(var(--sc-theme-calendar-font-large) * 0.7)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF5UGlja2VyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtSEMseUJBQVcsQ0FDVixPQUFPLENBQUUsSUFBSSxDQUNiLGtCQUFrQixDQUFFLElBQUksQ0FBQyxHQUMxQixDQUNBLHNCQUFRLENBQ1AsT0FBTyxDQUFFLElBQUksQ0FDYixhQUFhLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUNuQyxNQUFNLENBQUUsSUFBSSxpQ0FBaUMsQ0FBQyxDQUM5QyxPQUFPLENBQUUsQ0FBQyxDQUNWLFVBQVUsQ0FBRSxJQUFJLDZDQUE2QyxDQUFDLENBQzlELGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksaUNBQWlDLENBQUMsQ0FDL0QsV0FBVyxDQUFFLE1BQ2QsQ0FDQSxnQkFBRSxDQUNELFNBQVMsQ0FBRSxHQUNaLENBQ0EscUJBQU8sQ0FDTixPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxDQUFDLENBQ1gsV0FBVyxDQUFFLENBQ2QsQ0FDQSw0QkFBYyxDQUNiLEtBQUssQ0FBRSxJQUFJLCtDQUErQyxDQUFDLENBQzNELFVBQVUsQ0FBRSxJQUFJLDJDQUEyQyxDQUFDLENBQzVELFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLFNBQVMsQ0FBRSxJQUFJLDhCQUE4QixDQUFDLENBQzlDLE9BQU8sQ0FBRSxDQUFDLENBQ1YsT0FBTyxDQUFFLENBQUMsQ0FDVixXQUFXLENBQUUsQ0FDZCxDQUVBLE1BQU8sWUFBWSxLQUFLLENBQUUsQ0FDekIsNEJBQWMsQ0FDYixTQUFTLENBQUUsS0FBSyxJQUFJLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FDMUQsQ0FDRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEYXlQaWNrZXIuc3ZlbHRlIl19 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[21] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let span;
  let t_value = (
    /*label*/
    ctx[22] + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file4, 72, 3, 2148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(72:2) {#each legend as label}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let a;
  let t0_value = (
    /*day*/
    ctx[19].date.getDate() + ""
  );
  let t0;
  let t1;
  let a_intro;
  let a_outro;
  let current;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      t1 = claim_space(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", "#pickday");
      attr_dev(a, "class", "svelte-1unzsxu");
      toggle_class(a, "disabled", !/*store*/
      ctx[4].isSelectable(
        /*day*/
        ctx[19].date
      ));
      toggle_class(
        a,
        "selected",
        /*index*/
        ctx[18] === /*monthIndex*/
        ctx[0] && (0, import_dayjs2.default)(
          /*day*/
          ctx[19].date
        ).isSame(
          /*$store*/
          ctx[1].selected,
          "day"
        )
      );
      toggle_class(
        a,
        "outsider",
        /*day*/
        ctx[19].outsider
      );
      add_location(a, file4, 88, 7, 2659);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "keydown", prevent_default(
            /*keydown_handler*/
            ctx[10]
          ), false, true, false, false),
          listen_dev(
            a,
            "click",
            prevent_default(function() {
              if (is_function(
                /*select*/
                ctx[6](
                  /*day*/
                  ctx[19].date
                )
              ))
                ctx[6](
                  /*day*/
                  ctx[19].date
                ).apply(this, arguments);
            }),
            false,
            true,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*days*/
      131072) && t0_value !== (t0_value = /*day*/
      ctx[19].date.getDate() + ""))
        set_data_dev(t0, t0_value);
      if (!current || dirty & /*store, days*/
      131088) {
        toggle_class(a, "disabled", !/*store*/
        ctx[4].isSelectable(
          /*day*/
          ctx[19].date
        ));
      }
      if (!current || dirty & /*index, monthIndex, days, $store*/
      393219) {
        toggle_class(
          a,
          "selected",
          /*index*/
          ctx[18] === /*monthIndex*/
          ctx[0] && (0, import_dayjs2.default)(
            /*day*/
            ctx[19].date
          ).isSame(
            /*$store*/
            ctx[1].selected,
            "day"
          )
        );
      }
      if (!current || dirty & /*days*/
      131072) {
        toggle_class(
          a,
          "outsider",
          /*day*/
          ctx[19].outsider
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (a_outro)
            a_outro.end(1);
          a_intro = create_in_transition(
            a,
            /*receive*/
            ctx[15],
            { key: (
              /*key*/
              ctx[14]
            ) }
          );
          a_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (a_intro)
        a_intro.invalidate();
      if (local) {
        a_outro = create_out_transition(
          a,
          /*send*/
          ctx[16],
          { key: (
            /*key*/
            ctx[14]
          ) }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (detaching && a_outro)
        a_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(88:6) {#if !$store.enlargeDay || index !== monthIndex || !dayjs(day.date).isSame($store.selected)}",
    ctx
  });
  return block;
}
function create_each_block2(key_1, ctx) {
  let first;
  let show_if = !/*$store*/
  ctx[1].enlargeDay || /*index*/
  ctx[18] !== /*monthIndex*/
  ctx[0] || !(0, import_dayjs2.default)(
    /*day*/
    ctx[19].date
  ).isSame(
    /*$store*/
    ctx[1].selected
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_1(ctx);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$store, index, monthIndex, days*/
      393219)
        show_if = !/*$store*/
        ctx[1].enlargeDay || /*index*/
        ctx[18] !== /*monthIndex*/
        ctx[0] || !(0, import_dayjs2.default)(
          /*day*/
          ctx[19].date
        ).isSame(
          /*$store*/
          ctx[1].selected
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*$store, index, monthIndex, days*/
          393219) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(87:5) {#each days as day, i (day)}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*days*/
    ctx[17]
  );
  const get_key = (ctx2) => (
    /*day*/
    ctx2[19]
  );
  validate_each_keys(ctx, each_value, get_each_context2, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*key, store, days, index, monthIndex, $store, select*/
      409683) {
        each_value = ensure_array_like_dev(
          /*days*/
          ctx2[17]
        );
        validate_each_keys(ctx2, each_value, get_each_context2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block2, each_1_anchor, get_each_context2);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(86:4) <Grid template=\\"repeat(6, 1fr) / repeat(7, 1fr)\\">',
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let grid;
  let current;
  grid = new Grid_default({
    props: {
      template: "repeat(6, 1fr) / repeat(7, 1fr)",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(grid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(grid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(grid, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const grid_changes = {};
      if (dirty & /*$$scope, days, key, index, monthIndex, $store*/
      33964035) {
        grid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid.$set(grid_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(grid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(grid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(grid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(78:3) <InfiniteGrid     cellCount={1}     itemCount={totalMonths}     bind:index={monthIndex}     {get}     let:days     let:index    >",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let t_value = (0, import_dayjs2.default)(
    /*$store*/
    ctx[1].selected
  ).date() + "";
  let t;
  let div_intro;
  let div_outro;
  let current;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "stage selected-big svelte-1unzsxu");
      add_location(div, file4, 107, 3, 3181);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*$store*/
      2) && t_value !== (t_value = (0, import_dayjs2.default)(
        /*$store*/
        ctx[1].selected
      ).date() + ""))
        set_data_dev(t, t_value);
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*receive*/
            ctx[15],
            { key: (
              /*key*/
              ctx[14]
            ) }
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*send*/
          ctx[16],
          { key: (
            /*key*/
            ctx[14]
          ) }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(107:2) {#if $store.enlargeDay}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let div;
  let infinitegrid;
  let updating_index;
  let scrollable_action;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  function infinitegrid_index_binding(value) {
    ctx[11](value);
  }
  let infinitegrid_props = {
    cellCount: 1,
    itemCount: (
      /*totalMonths*/
      ctx[3]
    ),
    get: (
      /*get*/
      ctx[8]
    ),
    $$slots: {
      default: [
        create_default_slot_1,
        ({ days, index }) => ({ 17: days, 18: index }),
        ({ days, index }) => (days ? 131072 : 0) | (index ? 262144 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*monthIndex*/
    ctx[0] !== void 0
  ) {
    infinitegrid_props.index = /*monthIndex*/
    ctx[0];
  }
  infinitegrid = new InfiniteGrid_default({
    props: infinitegrid_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(infinitegrid, "index", infinitegrid_index_binding));
  let if_block = (
    /*$store*/
    ctx[1].enlargeDay && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(infinitegrid.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(infinitegrid.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "stage svelte-1unzsxu");
      add_location(div, file4, 76, 2, 2242);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(infinitegrid, div, null);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(scrollable_action = scrollable_default.call(null, div, { y: (
            /*initialY*/
            ctx[2]
          ), step: scrollStep })),
          listen_dev(
            div,
            "y",
            /*updateIndex*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      const infinitegrid_changes = {};
      if (dirty & /*totalMonths*/
      8)
        infinitegrid_changes.itemCount = /*totalMonths*/
        ctx2[3];
      if (dirty & /*$$scope, days, key, index, monthIndex, $store*/
      33964035) {
        infinitegrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_index && dirty & /*monthIndex*/
      1) {
        updating_index = true;
        infinitegrid_changes.index = /*monthIndex*/
        ctx2[0];
        add_flush_callback(() => updating_index = false);
      }
      infinitegrid.$set(infinitegrid_changes);
      if (scrollable_action && is_function(scrollable_action.update) && dirty & /*initialY*/
      4)
        scrollable_action.update.call(null, { y: (
          /*initialY*/
          ctx2[2]
        ), step: scrollStep });
      if (
        /*$store*/
        ctx2[1].enlargeDay
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$store*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infinitegrid.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(infinitegrid.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(infinitegrid);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(76:1) <Crossfade {duration} let:key let:receive let:send>",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let keycontrols;
  let t0;
  let div1;
  let div0;
  let t1;
  let crossfade2;
  let current;
  const keycontrols_spread_levels = [
    /*KEY_MAPPINGS*/
    ctx[7],
    { ctx: ["days"] }
  ];
  let keycontrols_props = {};
  for (let i = 0; i < keycontrols_spread_levels.length; i += 1) {
    keycontrols_props = assign(keycontrols_props, keycontrols_spread_levels[i]);
  }
  keycontrols = new KeyControls_default({ props: keycontrols_props, $$inline: true });
  let each_value_1 = ensure_array_like_dev(
    /*legend*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  crossfade2 = new Crossfade_default({
    props: {
      duration,
      $$slots: {
        default: [
          create_default_slot2,
          ({ key, receive, send }) => ({ 14: key, 15: receive, 16: send }),
          ({ key, receive, send }) => (key ? 16384 : 0) | (receive ? 32768 : 0) | (send ? 65536 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(keycontrols.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      create_component(crossfade2.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(keycontrols.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      claim_component(crossfade2.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "legend svelte-1unzsxu");
      add_location(div0, file4, 70, 1, 2098);
      attr_dev(div1, "class", "container svelte-1unzsxu");
      add_location(div1, file4, 69, 0, 2073);
    },
    m: function mount(target, anchor) {
      mount_component(keycontrols, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div1, t1);
      mount_component(crossfade2, div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const keycontrols_changes = dirty & /*KEY_MAPPINGS*/
      128 ? get_spread_update(keycontrols_spread_levels, [get_spread_object(
        /*KEY_MAPPINGS*/
        ctx2[7]
      ), keycontrols_spread_levels[1]]) : {};
      keycontrols.$set(keycontrols_changes);
      if (dirty & /*legend*/
      32) {
        each_value_1 = ensure_array_like_dev(
          /*legend*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      const crossfade_changes = {};
      if (dirty & /*$$scope, key, $store, initialY, totalMonths, monthIndex*/
      33570831) {
        crossfade_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crossfade2.$set(crossfade_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(keycontrols.$$.fragment, local);
      transition_in(crossfade2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(keycontrols.$$.fragment, local);
      transition_out(crossfade2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div1);
      }
      destroy_component(keycontrols, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(crossfade2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var duration = 450;
function instance7($$self, $$props, $$invalidate) {
  let totalMonths;
  let monthIndex;
  let initialY;
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DayPicker", slots, []);
  const store = getContext(storeContextKey);
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(1, $store = value));
  const legend = Array(7).fill(0).map((d, i) => (0, import_dayjs2.default)().day(($store.startOfWeekIndex + i) % 7).format("ddd"));
  const add = (amount) => () => store.add(amount, "day");
  const select = (day) => () => {
    if (!store.isSelectable(day))
      return;
    store.setDay(day || $store.selected);
    if (!$store.shouldEnlargeDay)
      return store.selectDay();
    store.enlargeDay();
    setTimeout(
      () => {
        store.selectDay();
        store.enlargeDay(false);
      },
      duration + 60
    );
  };
  const KEY_MAPPINGS = {
    left: add(-1),
    right: add(1),
    up: add(-7),
    down: add(7),
    enter: select(),
    escape: () => store.close()
  };
  const calPagesBetweenDates = (a, b) => {
    const yearDelta = b.getFullYear() - a.getFullYear();
    const firstPartialYear = yearDelta ? 12 - a.getMonth() : b.getMonth() - a.getMonth() + 1;
    const fullYears = yearDelta > 1 ? (yearDelta - 1) * 12 : 0;
    const lastPartialYear = yearDelta ? b.getMonth() + 1 : 0;
    return firstPartialYear + fullYears + lastPartialYear;
  };
  const get2 = (index) => {
    const d = (0, import_dayjs2.default)($store.start).add(index, "month");
    return {
      days: store.getCalendarPage(d.month(), d.year())
    };
  };
  const updateIndex = ({ detail: { step: newIndex } }) => {
    store.add(newIndex - monthIndex, "month", ["date"]);
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DayPicker> was created with unknown prop '${key}'`);
  });
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function infinitegrid_index_binding(value) {
    monthIndex = value;
    $$invalidate(0, monthIndex), $$invalidate(1, $store);
  }
  $$self.$capture_state = () => ({
    getContext,
    storeContextKey,
    KeyControls: KeyControls_default,
    Grid: Grid_default,
    InfiniteGrid: InfiniteGrid_default,
    dayjs: import_dayjs2.default,
    Crossfade: Crossfade_default,
    scrollable: scrollable_default,
    scrollStep,
    store,
    duration,
    legend,
    add,
    select,
    KEY_MAPPINGS,
    calPagesBetweenDates,
    get: get2,
    updateIndex,
    monthIndex,
    initialY,
    totalMonths,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("monthIndex" in $$props2)
      $$invalidate(0, monthIndex = $$props2.monthIndex);
    if ("initialY" in $$props2)
      $$invalidate(2, initialY = $$props2.initialY);
    if ("totalMonths" in $$props2)
      $$invalidate(3, totalMonths = $$props2.totalMonths);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$store*/
    2) {
      $:
        $$invalidate(3, totalMonths = calPagesBetweenDates($store.start, $store.end));
    }
    if ($$self.$$.dirty & /*$store*/
    2) {
      $:
        $$invalidate(0, monthIndex = calPagesBetweenDates($store.start, $store.selected) - 1);
    }
    if ($$self.$$.dirty & /*monthIndex*/
    1) {
      $:
        $$invalidate(2, initialY = monthIndex * scrollStep);
    }
  };
  return [
    monthIndex,
    $store,
    initialY,
    totalMonths,
    store,
    legend,
    select,
    KEY_MAPPINGS,
    get2,
    updateIndex,
    keydown_handler,
    infinitegrid_index_binding
  ];
}
var DayPicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {}, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DayPicker",
      options,
      id: create_fragment7.name
    });
  }
};
var DayPicker_default = DayPicker;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/ViewTransitionEffect.svelte
var file5 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\generic\\ViewTransitionEffect.svelte";
function create_fragment8(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file5, 8, 0, 197);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, scale, {
            start: (
              /*$store*/
              ctx[0].activeViewDirection * 0.5 + 1
            ),
            delay: 110
          });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, scale, {
          start: (
            /*$store*/
            ctx[0].activeViewDirection * -0.5 + 1
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewTransitionEffect", slots, ["default"]);
  const store = getContext(storeContextKey);
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(0, $store = value));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ViewTransitionEffect> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    scale,
    storeContextKey,
    getContext,
    store,
    $store
  });
  return [$store, store, $$scope, slots];
}
var ViewTransitionEffect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewTransitionEffect",
      options,
      id: create_fragment8.name
    });
  }
};
var ViewTransitionEffect_default = ViewTransitionEffect;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/Arrow.svelte
var file6 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\generic\\Arrow.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1eiemu5", "i.svelte-1eiemu5{display:inline-block;width:23px;height:23px;border-style:solid;border-color:var(--sc-theme-calendar-colors-text-primary);border-width:0;border-bottom-width:3px;border-right-width:3px;transform-origin:center center}i.right.svelte-1eiemu5{transform:translateX(-6px) rotate(-45deg)}i.left.svelte-1eiemu5{transform:translateX(6px) rotate(135deg)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXJyb3cuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQU9DLGdCQUFFLENBQ0QsT0FBTyxDQUFFLFlBQVksQ0FDckIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFlBQVksQ0FBRSxLQUFLLENBQ25CLFlBQVksQ0FBRSxJQUFJLHVDQUF1QyxDQUFDLENBQzFELFlBQVksQ0FBRSxDQUFDLENBQ2YsbUJBQW1CLENBQUUsR0FBRyxDQUN4QixrQkFBa0IsQ0FBRSxHQUFHLENBQ3ZCLGdCQUFnQixDQUFFLE1BQU0sQ0FBQyxNQUMxQixDQUNBLENBQUMscUJBQU8sQ0FDUCxTQUFTLENBQUUsV0FBVyxJQUFJLENBQUMsQ0FBQyxPQUFPLE1BQU0sQ0FDMUMsQ0FDQSxDQUFDLG9CQUFNLENBQ04sU0FBUyxDQUFFLFdBQVcsR0FBRyxDQUFDLENBQUMsT0FBTyxNQUFNLENBQ3pDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFycm93LnN2ZWx0ZSJdfQ== */");
}
function create_fragment9(ctx) {
  let i;
  let i_class_value;
  const block = {
    c: function create() {
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      i = claim_element(nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = null_to_empty(
        /*dir*/
        ctx[0]
      ) + " svelte-1eiemu5");
      add_location(i, file6, 4, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, i, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*dir*/
      1 && i_class_value !== (i_class_value = null_to_empty(
        /*dir*/
        ctx2[0]
      ) + " svelte-1eiemu5")) {
        attr_dev(i, "class", i_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(i);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Arrow", slots, []);
  let { dir = "left" } = $$props;
  const writable_props = ["dir"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Arrow> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
  };
  $$self.$capture_state = () => ({ dir });
  $$self.$inject_state = ($$props2) => {
    if ("dir" in $$props2)
      $$invalidate(0, dir = $$props2.dir);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [dir];
}
var Arrow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { dir: 0 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Arrow",
      options,
      id: create_fragment9.name
    });
  }
  get dir() {
    throw new Error("<Arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dir(value) {
    throw new Error("<Arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Arrow_default = Arrow;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/calendar/CalendarControls.svelte
var import_dayjs3 = __toESM(require_dayjs_min());
var file7 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\calendar\\CalendarControls.svelte";
function add_css6(target) {
  append_styles(target, "svelte-1ro74h8", ".controls.svelte-1ro74h8{display:grid;grid-template-columns:auto 1fr auto auto;align-items:center;text-align:center;z-index:2;border-bottom:1px solid var(--sc-theme-calendar-colors-border);font-size:1.5em;overflow:hidden}.controls.svelte-1ro74h8>*{height:80px;padding:0 17px;display:grid;align-items:center}.button.svelte-1ro74h8{padding:10px 18px;cursor:pointer;background:var(--sc-theme-calendar-colors-background-primary);transition:all 100ms linear}.button.svelte-1ro74h8:hover{background:var(--sc-theme-calendar-colors-background-hover)}.label.svelte-1ro74h8{font-weight:bold}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXJDb250cm9scy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaURDLHdCQUFVLENBQ1QsT0FBTyxDQUFFLElBQUksQ0FDYixxQkFBcUIsQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ3pDLFdBQVcsQ0FBRSxNQUFNLENBQ25CLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxpQ0FBaUMsQ0FBQyxDQUUvRCxTQUFTLENBQUUsS0FBSyxDQUVoQixRQUFRLENBQUUsTUFDWCxDQUNBLHdCQUFTLENBQVcsQ0FBRyxDQUN0QixNQUFNLENBQUUsSUFBSSxDQUNaLE9BQU8sQ0FBRSxDQUFDLENBQUMsSUFBSSxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQ2QsQ0FDQSxzQkFBUSxDQUNQLE9BQU8sQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLFVBQVUsQ0FBRSxJQUFJLDZDQUE2QyxDQUFDLENBQzlELFVBQVUsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQ3ZCLENBQ0Esc0JBQU8sTUFBTyxDQUNiLFVBQVUsQ0FBRSxJQUFJLDJDQUEyQyxDQUM1RCxDQUNBLHFCQUFPLENBQ04sV0FBVyxDQUFFLElBQ2QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ2FsZW5kYXJDb250cm9scy5zdmVsdGUiXX0= */");
}
function create_fragment10(ctx) {
  let keycontrols;
  let t0;
  let div2;
  let div0;
  let arrow0;
  let t1;
  let span;
  let t2;
  let t3;
  let div1;
  let arrow1;
  let current;
  let mounted;
  let dispose;
  const keycontrols_spread_levels = [
    { ctx: ["days", "months", "years"] },
    { limit: 180 },
    /*KEY_MAPPINGS*/
    ctx[4]
  ];
  let keycontrols_props = {};
  for (let i = 0; i < keycontrols_spread_levels.length; i += 1) {
    keycontrols_props = assign(keycontrols_props, keycontrols_spread_levels[i]);
  }
  keycontrols = new KeyControls_default({ props: keycontrols_props, $$inline: true });
  arrow0 = new Arrow_default({ props: { dir: "left" }, $$inline: true });
  arrow1 = new Arrow_default({ props: { dir: "right" }, $$inline: true });
  const block = {
    c: function create() {
      create_component(keycontrols.$$.fragment);
      t0 = space();
      div2 = element("div");
      div0 = element("div");
      create_component(arrow0.$$.fragment);
      t1 = space();
      span = element("span");
      t2 = text(
        /*label*/
        ctx[0]
      );
      t3 = space();
      div1 = element("div");
      create_component(arrow1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(keycontrols.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(arrow0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      span = claim_element(div2_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t2 = claim_text(
        span_nodes,
        /*label*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(arrow1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "button svelte-1ro74h8");
      add_location(div0, file7, 37, 1, 1197);
      attr_dev(span, "class", "button label svelte-1ro74h8");
      add_location(span, file7, 40, 1, 1269);
      attr_dev(div1, "class", "button svelte-1ro74h8");
      add_location(div1, file7, 43, 1, 1345);
      attr_dev(div2, "class", "controls svelte-1ro74h8");
      add_location(div2, file7, 36, 0, 1173);
    },
    m: function mount(target, anchor) {
      mount_component(keycontrols, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      mount_component(arrow0, div0, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, span);
      append_hydration_dev(span, t2);
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, div1);
      mount_component(arrow1, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div0,
            "click",
            /*add*/
            ctx[2](-1),
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "click",
            /*updateActiveView*/
            ctx[3],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*add*/
            ctx[2](1),
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const keycontrols_changes = dirty & /*KEY_MAPPINGS*/
      16 ? get_spread_update(keycontrols_spread_levels, [
        keycontrols_spread_levels[0],
        keycontrols_spread_levels[1],
        get_spread_object(
          /*KEY_MAPPINGS*/
          ctx2[4]
        )
      ]) : {};
      keycontrols.$set(keycontrols_changes);
      if (!current || dirty & /*label*/
      1)
        set_data_dev(
          t2,
          /*label*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(keycontrols.$$.fragment, local);
      transition_in(arrow0.$$.fragment, local);
      transition_in(arrow1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(keycontrols.$$.fragment, local);
      transition_out(arrow0.$$.fragment, local);
      transition_out(arrow1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div2);
      }
      destroy_component(keycontrols, detaching);
      destroy_component(arrow0);
      destroy_component(arrow1);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let visibleMonth;
  let label;
  let addMult;
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CalendarControls", slots, []);
  const store = getContext(storeContextKey);
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(6, $store = value));
  const UNIT_BY_VIEW = {
    days: "month",
    months: "year",
    years: "year"
  };
  const add = (amount) => () => store.add(amount * addMult, UNIT_BY_VIEW[$store.activeView]);
  const VIEW_TRANSITIONS = ["days", "months", "years"];
  const updateActiveView = () => {
    const transitionIndex = VIEW_TRANSITIONS.indexOf($store.activeView) + 1;
    const newView = transitionIndex ? VIEW_TRANSITIONS[transitionIndex] : null;
    if (newView)
      store.setActiveView(newView);
  };
  const KEY_MAPPINGS = {
    pageDown: add(-1),
    pageUp: add(1),
    control: updateActiveView
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CalendarControls> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    Arrow: Arrow_default,
    getContext,
    storeContextKey,
    dayjs: import_dayjs3.default,
    KeyControls: KeyControls_default,
    store,
    UNIT_BY_VIEW,
    add,
    VIEW_TRANSITIONS,
    updateActiveView,
    KEY_MAPPINGS,
    addMult,
    visibleMonth,
    label,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("addMult" in $$props2)
      addMult = $$props2.addMult;
    if ("visibleMonth" in $$props2)
      $$invalidate(5, visibleMonth = $$props2.visibleMonth);
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$store*/
    64) {
      $:
        $$invalidate(5, visibleMonth = (0, import_dayjs3.default)(new Date($store.year, $store.month, 1)));
    }
    if ($$self.$$.dirty & /*$store, visibleMonth*/
    96) {
      $:
        $$invalidate(0, label = `${$store.activeView === "days" ? visibleMonth.format("MMMM ") : ""}${$store.year}`);
    }
    if ($$self.$$.dirty & /*$store*/
    64) {
      $:
        addMult = $store.activeView === "years" ? 10 : 1;
    }
  };
  return [label, store, add, updateActiveView, KEY_MAPPINGS, visibleMonth, $store];
}
var CalendarControls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {}, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CalendarControls",
      options,
      id: create_fragment10.name
    });
  }
};
var CalendarControls_default = CalendarControls;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/crossfade/CrossfadeProvider.svelte
var get_default_slot_changes5 = (dirty) => ({
  key: dirty & /*$store*/
  1,
  send: dirty & /*$store*/
  1,
  receive: dirty & /*$store*/
  1
});
var get_default_slot_context5 = (ctx) => ({
  key: (
    /*$store*/
    ctx[0].key
  ),
  send: (
    /*$store*/
    ctx[0].send
  ),
  receive: (
    /*$store*/
    ctx[0].receive
  )
});
function create_fragment11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $store*/
        5)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CrossfadeProvider", slots, ["default"]);
  const noop2 = () => false;
  const store = getContext("crossfade") || writable({ send: noop2, receive: noop2 });
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(0, $store = value));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CrossfadeProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    writable,
    noop: noop2,
    store,
    $store
  });
  return [$store, store, $$scope, slots];
}
var CrossfadeProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CrossfadeProvider",
      options,
      id: create_fragment11.name
    });
  }
};
var CrossfadeProvider_default = CrossfadeProvider;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/calendar/MonthPicker.svelte
var import_dayjs4 = __toESM(require_dayjs_min());
var file8 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\calendar\\MonthPicker.svelte";
function add_css7(target) {
  append_styles(target, "svelte-t161t", "div.svelte-t161t{display:grid;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9udGhQaWNrZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTZFQyxnQkFBSSxDQUNILE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLElBQ1QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTW9udGhQaWNrZXIuc3ZlbHRlIl19 */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
function create_each_block3(ctx) {
  let a;
  let t0_value = (
    /*month*/
    ctx[15].label + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      t1 = claim_space(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", "#selectMonth");
      toggle_class(
        a,
        "disabled",
        /*month*/
        ctx[15].disabled
      );
      toggle_class(
        a,
        "selected",
        /*$store*/
        ctx[1].month === /*i*/
        ctx[17] && /*$store*/
        ctx[1].year === /*month*/
        ctx[15].year
      );
      add_location(a, file8, 63, 4, 1837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, t1);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          prevent_default(function() {
            if (is_function(
              /*select*/
              ctx[7](
                /*month*/
                ctx[15]
              )
            ))
              ctx[7](
                /*month*/
                ctx[15]
              ).apply(this, arguments);
          }),
          false,
          true,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*months*/
      16384 && t0_value !== (t0_value = /*month*/
      ctx[15].label + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*months*/
      16384) {
        toggle_class(
          a,
          "disabled",
          /*month*/
          ctx[15].disabled
        );
      }
      if (dirty & /*$store, months*/
      16386) {
        toggle_class(
          a,
          "selected",
          /*$store*/
          ctx[1].month === /*i*/
          ctx[17] && /*$store*/
          ctx[1].year === /*month*/
          ctx[15].year
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(63:3) {#each months as month, i}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*months*/
    ctx[14]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*months, $store, select*/
      16514) {
        each_value = ensure_array_like_dev(
          /*months*/
          ctx2[14]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(62:2) <Grid template=\\"repeat(4, 1fr) / repeat(3, 1fr)\\">',
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let grid_1;
  let current;
  grid_1 = new Grid_default({
    props: {
      template: "repeat(4, 1fr) / repeat(3, 1fr)",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(grid_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(grid_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(grid_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const grid_1_changes = {};
      if (dirty & /*$$scope, months, $store*/
      278530) {
        grid_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid_1.$set(grid_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(grid_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(grid_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(grid_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(61:1) <InfiniteGrid cellCount={1} {itemCount} bind:index={yearIndex} {get} let:months bind:this={grid}>",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let keycontrols;
  let t;
  let div;
  let infinitegrid;
  let updating_index;
  let scrollable_action;
  let current;
  let mounted;
  let dispose;
  const keycontrols_spread_levels = [
    /*KEY_MAPPINGS*/
    ctx[9],
    { ctx: ["months"] }
  ];
  let keycontrols_props = {};
  for (let i = 0; i < keycontrols_spread_levels.length; i += 1) {
    keycontrols_props = assign(keycontrols_props, keycontrols_spread_levels[i]);
  }
  keycontrols = new KeyControls_default({ props: keycontrols_props, $$inline: true });
  function infinitegrid_index_binding(value) {
    ctx[10](value);
  }
  let infinitegrid_props = {
    cellCount: 1,
    itemCount: (
      /*itemCount*/
      ctx[3]
    ),
    get: (
      /*get*/
      ctx[6]
    ),
    $$slots: {
      default: [
        create_default_slot3,
        ({ months }) => ({ 14: months }),
        ({ months }) => months ? 16384 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*yearIndex*/
    ctx[0] !== void 0
  ) {
    infinitegrid_props.index = /*yearIndex*/
    ctx[0];
  }
  infinitegrid = new InfiniteGrid_default({
    props: infinitegrid_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(infinitegrid, "index", infinitegrid_index_binding));
  ctx[11](infinitegrid);
  const block = {
    c: function create() {
      create_component(keycontrols.$$.fragment);
      t = space();
      div = element("div");
      create_component(infinitegrid.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(keycontrols.$$.fragment, nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(infinitegrid.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-t161t");
      add_location(div, file8, 59, 0, 1555);
    },
    m: function mount(target, anchor) {
      mount_component(keycontrols, target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      mount_component(infinitegrid, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(scrollable_action = scrollable_default.call(null, div, {
            y: (
              /*initialY*/
              ctx[4]
            ),
            step: scrollStep,
            maxSteps: (
              /*itemCount*/
              ctx[3]
            )
          })),
          listen_dev(
            div,
            "y",
            /*updateIndex*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const keycontrols_changes = dirty & /*KEY_MAPPINGS*/
      512 ? get_spread_update(keycontrols_spread_levels, [get_spread_object(
        /*KEY_MAPPINGS*/
        ctx2[9]
      ), keycontrols_spread_levels[1]]) : {};
      keycontrols.$set(keycontrols_changes);
      const infinitegrid_changes = {};
      if (dirty & /*itemCount*/
      8)
        infinitegrid_changes.itemCount = /*itemCount*/
        ctx2[3];
      if (dirty & /*$$scope, months, $store*/
      278530) {
        infinitegrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_index && dirty & /*yearIndex*/
      1) {
        updating_index = true;
        infinitegrid_changes.index = /*yearIndex*/
        ctx2[0];
        add_flush_callback(() => updating_index = false);
      }
      infinitegrid.$set(infinitegrid_changes);
      if (scrollable_action && is_function(scrollable_action.update) && dirty & /*initialY, itemCount*/
      24)
        scrollable_action.update.call(null, {
          y: (
            /*initialY*/
            ctx2[4]
          ),
          step: scrollStep,
          maxSteps: (
            /*itemCount*/
            ctx2[3]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(keycontrols.$$.fragment, local);
      transition_in(infinitegrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(keycontrols.$$.fragment, local);
      transition_out(infinitegrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      destroy_component(keycontrols, detaching);
      ctx[11](null);
      destroy_component(infinitegrid);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let yearIndex;
  let initialY;
  let itemCount;
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MonthPicker", slots, []);
  const store = getContext(storeContextKey);
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(1, $store = value));
  let grid;
  const get2 = (index) => ({
    months: Array(12).fill(0).map((d, i) => {
      const month = (0, import_dayjs4.default)(new Date($store.start.getFullYear() + index, i, 1));
      return {
        year: $store.start.getFullYear() + index,
        label: month.format("MMM"),
        index: i,
        disabled: !store.isSelectable(month, ["date"])
      };
    })
  });
  const close = () => store.setActiveView("days");
  const select = (month) => () => {
    if (month.disabled)
      return;
    store.setMonth(month.index);
    close();
  };
  const add = (amount) => () => {
    store.add(amount, "month", ["date"]);
  };
  const updateIndex = ({ detail: { step: newIndex } }) => {
    store.add(newIndex - yearIndex, "year", ["month", "date"]);
  };
  const KEY_MAPPINGS = {
    left: add(-1),
    right: add(1),
    up: add(-3),
    down: add(3),
    enter: close,
    escape: close
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MonthPicker> was created with unknown prop '${key}'`);
  });
  function infinitegrid_index_binding(value) {
    yearIndex = value;
    $$invalidate(0, yearIndex), $$invalidate(1, $store);
  }
  function infinitegrid_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      grid = $$value;
      $$invalidate(2, grid);
    });
  }
  $$self.$capture_state = () => ({
    getContext,
    storeContextKey,
    dayjs: import_dayjs4.default,
    KeyControls: KeyControls_default,
    Grid: Grid_default,
    InfiniteGrid: InfiniteGrid_default,
    scrollable: scrollable_default,
    scrollStep,
    store,
    grid,
    get: get2,
    close,
    select,
    add,
    updateIndex,
    KEY_MAPPINGS,
    itemCount,
    yearIndex,
    initialY,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("grid" in $$props2)
      $$invalidate(2, grid = $$props2.grid);
    if ("itemCount" in $$props2)
      $$invalidate(3, itemCount = $$props2.itemCount);
    if ("yearIndex" in $$props2)
      $$invalidate(0, yearIndex = $$props2.yearIndex);
    if ("initialY" in $$props2)
      $$invalidate(4, initialY = $$props2.initialY);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$store*/
    2) {
      $:
        $$invalidate(0, yearIndex = $store.year - $store.start.getFullYear());
    }
    if ($$self.$$.dirty & /*yearIndex*/
    1) {
      $:
        $$invalidate(4, initialY = yearIndex * scrollStep);
    }
    if ($$self.$$.dirty & /*$store*/
    2) {
      $:
        $$invalidate(3, itemCount = $store.end.getFullYear() - $store.start.getFullYear() + 1);
    }
  };
  return [
    yearIndex,
    $store,
    grid,
    itemCount,
    initialY,
    store,
    get2,
    select,
    updateIndex,
    KEY_MAPPINGS,
    infinitegrid_index_binding,
    infinitegrid_binding
  ];
}
var MonthPicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {}, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MonthPicker",
      options,
      id: create_fragment12.name
    });
  }
};
var MonthPicker_default = MonthPicker;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/calendar/YearPicker.svelte
var file9 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\calendar\\YearPicker.svelte";
function add_css8(target) {
  append_styles(target, "svelte-t161t", "div.svelte-t161t{display:grid;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiWWVhclBpY2tlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBOEVDLGdCQUFJLENBQ0gsT0FBTyxDQUFFLElBQUksQ0FDYixNQUFNLENBQUUsSUFDVCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJZZWFyUGlja2VyLnN2ZWx0ZSJdfQ== */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let a;
  let t0_value = (
    /*year*/
    ctx[18].number + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", { href: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      t1 = claim_space(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", "#year");
      toggle_class(
        a,
        "selected",
        /*$store*/
        ctx[3].year === /*year*/
        ctx[18].number
      );
      toggle_class(a, "disabled", !/*year*/
      ctx[18].selectable);
      add_location(a, file9, 64, 4, 2010);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, t0);
      append_hydration_dev(a, t1);
      if (!mounted) {
        dispose = listen_dev(
          a,
          "click",
          prevent_default(function() {
            if (is_function(
              /*select*/
              ctx[10](
                /*year*/
                ctx[18]
              )
            ))
              ctx[10](
                /*year*/
                ctx[18]
              ).apply(this, arguments);
          }),
          false,
          true,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*years*/
      131072 && t0_value !== (t0_value = /*year*/
      ctx[18].number + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*$store, years*/
      131080) {
        toggle_class(
          a,
          "selected",
          /*$store*/
          ctx[3].year === /*year*/
          ctx[18].number
        );
      }
      if (dirty & /*years*/
      131072) {
        toggle_class(a, "disabled", !/*year*/
        ctx[18].selectable);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(64:3) {#each years as year}",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*years*/
    ctx[17]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$store, years, select*/
      132104) {
        each_value = ensure_array_like_dev(
          /*years*/
          ctx2[17]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(63:2) <Grid template=\\"repeat({rowCount}, 1fr) / repeat({colCount}, 1fr)\\">',
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let grid;
  let current;
  grid = new Grid_default({
    props: {
      template: "repeat(" + /*rowCount*/
      ctx[0] + ", 1fr) / repeat(" + /*colCount*/
      ctx[1] + ", 1fr)",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(grid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(grid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(grid, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const grid_changes = {};
      if (dirty & /*rowCount, colCount*/
      3)
        grid_changes.template = "repeat(" + /*rowCount*/
        ctx2[0] + ", 1fr) / repeat(" + /*colCount*/
        ctx2[1] + ", 1fr)";
      if (dirty & /*$$scope, years, $store*/
      2228232) {
        grid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid.$set(grid_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(grid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(grid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(grid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(62:1) <InfiniteGrid cellCount={1} {itemCount} bind:index={yearIndex} {get} let:years>",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let keycontrols;
  let t;
  let div;
  let infinitegrid;
  let updating_index;
  let scrollable_action;
  let current;
  let mounted;
  let dispose;
  const keycontrols_spread_levels = [
    /*KEY_MAPPINGS*/
    ctx[6],
    { ctx: ["years"] }
  ];
  let keycontrols_props = {};
  for (let i = 0; i < keycontrols_spread_levels.length; i += 1) {
    keycontrols_props = assign(keycontrols_props, keycontrols_spread_levels[i]);
  }
  keycontrols = new KeyControls_default({ props: keycontrols_props, $$inline: true });
  function infinitegrid_index_binding(value) {
    ctx[14](value);
  }
  let infinitegrid_props = {
    cellCount: 1,
    itemCount: (
      /*itemCount*/
      ctx[5]
    ),
    get: (
      /*get*/
      ctx[8]
    ),
    $$slots: {
      default: [
        create_default_slot4,
        ({ years }) => ({ 17: years }),
        ({ years }) => years ? 131072 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*yearIndex*/
    ctx[2] !== void 0
  ) {
    infinitegrid_props.index = /*yearIndex*/
    ctx[2];
  }
  infinitegrid = new InfiniteGrid_default({
    props: infinitegrid_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(infinitegrid, "index", infinitegrid_index_binding));
  const block = {
    c: function create() {
      create_component(keycontrols.$$.fragment);
      t = space();
      div = element("div");
      create_component(infinitegrid.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(keycontrols.$$.fragment, nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(infinitegrid.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-t161t");
      add_location(div, file9, 60, 0, 1733);
    },
    m: function mount(target, anchor) {
      mount_component(keycontrols, target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      mount_component(infinitegrid, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(scrollable_action = scrollable_default.call(null, div, {
            y: (
              /*initialY*/
              ctx[4]
            ),
            step: scrollStep,
            maxSteps: (
              /*itemCount*/
              ctx[5]
            )
          })),
          listen_dev(
            div,
            "y",
            /*updateIndex*/
            ctx[9],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const keycontrols_changes = dirty & /*KEY_MAPPINGS*/
      64 ? get_spread_update(keycontrols_spread_levels, [get_spread_object(
        /*KEY_MAPPINGS*/
        ctx2[6]
      ), keycontrols_spread_levels[1]]) : {};
      keycontrols.$set(keycontrols_changes);
      const infinitegrid_changes = {};
      if (dirty & /*itemCount*/
      32)
        infinitegrid_changes.itemCount = /*itemCount*/
        ctx2[5];
      if (dirty & /*$$scope, rowCount, colCount, years, $store*/
      2228235) {
        infinitegrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_index && dirty & /*yearIndex*/
      4) {
        updating_index = true;
        infinitegrid_changes.index = /*yearIndex*/
        ctx2[2];
        add_flush_callback(() => updating_index = false);
      }
      infinitegrid.$set(infinitegrid_changes);
      if (scrollable_action && is_function(scrollable_action.update) && dirty & /*initialY, itemCount*/
      48)
        scrollable_action.update.call(null, {
          y: (
            /*initialY*/
            ctx2[4]
          ),
          step: scrollStep,
          maxSteps: (
            /*itemCount*/
            ctx2[5]
          )
        });
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(keycontrols.$$.fragment, local);
      transition_in(infinitegrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(keycontrols.$$.fragment, local);
      transition_out(infinitegrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      destroy_component(keycontrols, detaching);
      destroy_component(infinitegrid);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let KEY_MAPPINGS;
  let startYear;
  let endYear;
  let numPerPage;
  let itemCount;
  let yearIndex;
  let initialY;
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("YearPicker", slots, []);
  let { rowCount = 3 } = $$props;
  let { colCount = 3 } = $$props;
  const store = getContext(storeContextKey);
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(3, $store = value));
  const close = () => store.setActiveView("months");
  const add = (amount) => () => {
    const result = $store.year + amount;
    if (result < startYear || result > endYear)
      return;
    store.add(amount, "year", ["month", "date"]);
  };
  const get2 = (index) => {
    const firstYear = startYear + index * numPerPage;
    return {
      years: Array(numPerPage).fill(0).map((d, i) => ({
        number: firstYear + i,
        selectable: firstYear + i <= endYear
      }))
    };
  };
  const updateIndex = ({ detail: { step: newIndex } }) => {
    store.add(numPerPage * (newIndex - yearIndex), "year", ["year", "month", "date"]);
  };
  const select = (year) => () => {
    if (!year.selectable)
      return;
    store.setYear(year.number);
    close();
  };
  const writable_props = ["rowCount", "colCount"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<YearPicker> was created with unknown prop '${key}'`);
  });
  function infinitegrid_index_binding(value) {
    yearIndex = value;
    $$invalidate(2, yearIndex), $$invalidate(3, $store), $$invalidate(12, startYear), $$invalidate(11, numPerPage), $$invalidate(0, rowCount), $$invalidate(1, colCount);
  }
  $$self.$$set = ($$props2) => {
    if ("rowCount" in $$props2)
      $$invalidate(0, rowCount = $$props2.rowCount);
    if ("colCount" in $$props2)
      $$invalidate(1, colCount = $$props2.colCount);
  };
  $$self.$capture_state = () => ({
    getContext,
    storeContextKey,
    KeyControls: KeyControls_default,
    Grid: Grid_default,
    InfiniteGrid: InfiniteGrid_default,
    scrollable: scrollable_default,
    scrollStep,
    rowCount,
    colCount,
    store,
    close,
    add,
    get: get2,
    updateIndex,
    select,
    yearIndex,
    initialY,
    numPerPage,
    startYear,
    endYear,
    itemCount,
    KEY_MAPPINGS,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("rowCount" in $$props2)
      $$invalidate(0, rowCount = $$props2.rowCount);
    if ("colCount" in $$props2)
      $$invalidate(1, colCount = $$props2.colCount);
    if ("yearIndex" in $$props2)
      $$invalidate(2, yearIndex = $$props2.yearIndex);
    if ("initialY" in $$props2)
      $$invalidate(4, initialY = $$props2.initialY);
    if ("numPerPage" in $$props2)
      $$invalidate(11, numPerPage = $$props2.numPerPage);
    if ("startYear" in $$props2)
      $$invalidate(12, startYear = $$props2.startYear);
    if ("endYear" in $$props2)
      $$invalidate(13, endYear = $$props2.endYear);
    if ("itemCount" in $$props2)
      $$invalidate(5, itemCount = $$props2.itemCount);
    if ("KEY_MAPPINGS" in $$props2)
      $$invalidate(6, KEY_MAPPINGS = $$props2.KEY_MAPPINGS);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*colCount*/
    2) {
      $:
        $$invalidate(6, KEY_MAPPINGS = {
          up: add(-1 * colCount),
          down: add(colCount),
          left: add(-1),
          right: add(1),
          enter: close,
          escape: close
        });
    }
    if ($$self.$$.dirty & /*$store*/
    8) {
      $:
        $$invalidate(12, startYear = $store.start.getFullYear());
    }
    if ($$self.$$.dirty & /*$store*/
    8) {
      $:
        $$invalidate(13, endYear = $store.end.getFullYear());
    }
    if ($$self.$$.dirty & /*rowCount, colCount*/
    3) {
      $:
        $$invalidate(11, numPerPage = rowCount * colCount);
    }
    if ($$self.$$.dirty & /*endYear, startYear, numPerPage*/
    14336) {
      $:
        $$invalidate(5, itemCount = Math.ceil(endYear - startYear + 1) / numPerPage);
    }
    if ($$self.$$.dirty & /*$store, startYear, numPerPage*/
    6152) {
      $:
        $$invalidate(2, yearIndex = Math.floor(($store.year - startYear) / numPerPage));
    }
    if ($$self.$$.dirty & /*yearIndex*/
    4) {
      $:
        $$invalidate(4, initialY = yearIndex * scrollStep);
    }
  };
  return [
    rowCount,
    colCount,
    yearIndex,
    $store,
    initialY,
    itemCount,
    KEY_MAPPINGS,
    store,
    get2,
    updateIndex,
    select,
    numPerPage,
    startYear,
    endYear,
    infinitegrid_index_binding
  ];
}
var YearPicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { rowCount: 0, colCount: 1 }, add_css8);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "YearPicker",
      options,
      id: create_fragment13.name
    });
  }
  get rowCount() {
    throw new Error("<YearPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowCount(value) {
    throw new Error("<YearPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get colCount() {
    throw new Error("<YearPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set colCount(value) {
    throw new Error("<YearPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var YearPicker_default = YearPicker;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/calendar/Calendar.svelte
var file10 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\calendar\\Calendar.svelte";
function add_css9(target) {
  append_styles(target, "svelte-126ec0f", ".grid.svelte-126ec0f.svelte-126ec0f{display:grid;width:var(--sc-theme-calendar-width);max-width:var(--sc-theme-calendar-maxWidth);grid-template-rows:auto calc(\n				min(var(--sc-theme-calendar-maxWidth), var(--sc-theme-calendar-width)) * 6 / 7 +\n					var(--sc-theme-calendar-legend-height)\n			);font-family:Rajdhani, -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial,\n			sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';box-shadow:var(--sc-theme-calendar-shadow);background:var(--sc-theme-calendar-colors-background-primary);text-align:center;color:var(--sc-theme-calendar-colors-text-primary)}.contents.svelte-126ec0f.svelte-126ec0f{display:grid;overflow:hidden}.grid.svelte-126ec0f .contents.svelte-126ec0f>*{display:grid;grid-row:1;grid-column:1;height:100%;grid-template:1fr / 1fr}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FsZW5kYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1DQyxtQ0FBTSxDQUNMLE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLElBQUkseUJBQXlCLENBQUMsQ0FDckMsU0FBUyxDQUFFLElBQUksNEJBQTRCLENBQUMsQ0FDNUMsa0JBQWtCLENBQUUsSUFBSSxDQUFDO0FBQzNCLElBQUksSUFBSSxJQUFJLDRCQUE0QixDQUFDLENBQUMsQ0FBQyxJQUFJLHlCQUF5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkYsS0FBSyxJQUFJLGlDQUFpQztBQUMxQyxJQUFJLENBQ0YsV0FBVyxDQUFFLFFBQVEsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSztBQUN4RixHQUFHLFVBQVUsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxpQkFBaUIsQ0FDckUsVUFBVSxDQUFFLElBQUksMEJBQTBCLENBQUMsQ0FDM0MsVUFBVSxDQUFFLElBQUksNkNBQTZDLENBQUMsQ0FDOUQsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsS0FBSyxDQUFFLElBQUksdUNBQXVDLENBQ25ELENBQ0EsdUNBQVUsQ0FDVCxPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxNQUNYLENBQ0Esb0JBQUssQ0FBQyx3QkFBUyxDQUFXLENBQUcsQ0FDNUIsT0FBTyxDQUFFLElBQUksQ0FDYixRQUFRLENBQUUsQ0FBQyxDQUNYLFdBQVcsQ0FBRSxDQUFDLENBQ2QsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUN0QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDYWxlbmRhci5zdmVsdGUiXX0= */");
}
function create_if_block_2(ctx) {
  let viewtransitioneffect;
  let current;
  viewtransitioneffect = new ViewTransitionEffect_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(viewtransitioneffect.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(viewtransitioneffect.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(viewtransitioneffect, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(viewtransitioneffect.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(viewtransitioneffect.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(viewtransitioneffect, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(26:43) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let viewtransitioneffect;
  let current;
  viewtransitioneffect = new ViewTransitionEffect_default({
    props: {
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(viewtransitioneffect.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(viewtransitioneffect.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(viewtransitioneffect, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(viewtransitioneffect.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(viewtransitioneffect.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(viewtransitioneffect, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(22:44) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let viewtransitioneffect;
  let current;
  viewtransitioneffect = new ViewTransitionEffect_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(viewtransitioneffect.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(viewtransitioneffect.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(viewtransitioneffect, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(viewtransitioneffect.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(viewtransitioneffect.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(viewtransitioneffect, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(18:3) {#if $store.activeView === 'days'}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let yearpicker;
  let current;
  yearpicker = new YearPicker_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(yearpicker.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(yearpicker.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(yearpicker, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(yearpicker.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(yearpicker.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(yearpicker, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(27:4) <ViewTransitionEffect>",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let monthpicker;
  let current;
  monthpicker = new MonthPicker_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(monthpicker.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(monthpicker.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(monthpicker, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(monthpicker.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(monthpicker.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(monthpicker, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(23:4) <ViewTransitionEffect>",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let daypicker;
  let current;
  daypicker = new DayPicker_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(daypicker.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(daypicker.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(daypicker, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(daypicker.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(daypicker.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(daypicker, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(19:4) <ViewTransitionEffect>",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let div1;
  let datepickercontrols;
  let t;
  let div0;
  let current_block_type_index;
  let if_block;
  let div1_intro;
  let div1_outro;
  let current;
  datepickercontrols = new CalendarControls_default({ $$inline: true });
  const if_block_creators = [create_if_block3, create_if_block_12, create_if_block_2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$store*/
      ctx2[0].activeView === "days"
    )
      return 0;
    if (
      /*$store*/
      ctx2[0].activeView === "months"
    )
      return 1;
    if (
      /*$store*/
      ctx2[0].activeView === "years"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(datepickercontrols.$$.fragment);
      t = space();
      div0 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(datepickercontrols.$$.fragment, div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "contents svelte-126ec0f");
      add_location(div0, file10, 16, 2, 783);
      attr_dev(div1, "class", "grid svelte-126ec0f");
      add_location(div1, file10, 14, 1, 685);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(datepickercontrols, div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
          }
          transition_in(if_block, 1);
          if_block.m(div0, null);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(datepickercontrols.$$.fragment, local);
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div1_outro)
            div1_outro.end(1);
          div1_intro = create_in_transition(
            div1,
            /*receive*/
            ctx[4],
            { key: (
              /*key*/
              ctx[2]
            ) }
          );
          div1_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(datepickercontrols.$$.fragment, local);
      transition_out(if_block);
      if (div1_intro)
        div1_intro.invalidate();
      if (local) {
        div1_outro = create_out_transition(
          div1,
          /*send*/
          ctx[3],
          { key: (
            /*key*/
            ctx[2]
          ) }
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(datepickercontrols);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div1_outro)
        div1_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(14:0) <CrossfadeProvider let:key let:send let:receive>",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let crossfadeprovider;
  let current;
  crossfadeprovider = new CrossfadeProvider_default({
    props: {
      $$slots: {
        default: [
          create_default_slot5,
          ({ key, send, receive }) => ({ 2: key, 3: send, 4: receive }),
          ({ key, send, receive }) => (key ? 4 : 0) | (send ? 8 : 0) | (receive ? 16 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(crossfadeprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(crossfadeprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(crossfadeprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const crossfadeprovider_changes = {};
      if (dirty & /*$$scope, key, $store*/
      37) {
        crossfadeprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crossfadeprovider.$set(crossfadeprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(crossfadeprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(crossfadeprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(crossfadeprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  const store = getContext(storeContextKey);
  validate_store(store, "store");
  component_subscribe($$self, store, (value) => $$invalidate(0, $store = value));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Calendar> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    DayPicker: DayPicker_default,
    ViewTransitionEffect: ViewTransitionEffect_default,
    DatepickerControls: CalendarControls_default,
    getContext,
    storeContextKey,
    CrossfadeProvider: CrossfadeProvider_default,
    MonthPicker: MonthPicker_default,
    YearPicker: YearPicker_default,
    store,
    $store
  });
  return [$store, store];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {}, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment14.name
    });
  }
};
var Calendar_default = Calendar;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/config/defaults.js
var import_dayjs5 = __toESM(require_dayjs_min(), 1);
var calendar = {
  selected: /* @__PURE__ */ new Date(),
  start: (0, import_dayjs5.default)().add(-100, "year").toDate(),
  end: (0, import_dayjs5.default)().add(100, "year").toDate(),
  format: "MM/DD/YYYY"
};

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/Datepicker.svelte
var file11 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\Datepicker.svelte";
function add_css10(target) {
  append_styles(target, "svelte-18igz6t", ".button-container.svelte-18igz6t.svelte-18igz6t{display:grid}.button-container.svelte-18igz6t>.svelte-18igz6t{grid-column:1;grid-row:1;height:100%}button.svelte-18igz6t.svelte-18igz6t{padding:16px 30px;background:var(--sc-theme-calendar-colors-background-primary);color:var(--sc-theme-calendar-colors-text-primary);font-size:1.3em;border-radius:2px;border:0;box-shadow:4px 3px 9px rgb(0 0 0 / 20%);cursor:pointer}.button-text.svelte-18igz6t.svelte-18igz6t{padding:16px 30px;color:var(--sc-theme-calendar-colors-text-primary);font-size:1.3em;cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZXBpY2tlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcURDLCtDQUFrQixDQUNqQixPQUFPLENBQUUsSUFDVixDQUNBLGdDQUFpQixDQUFHLGVBQUUsQ0FDckIsV0FBVyxDQUFFLENBQUMsQ0FDZCxRQUFRLENBQUUsQ0FBQyxDQUNYLE1BQU0sQ0FBRSxJQUNULENBQ0Esb0NBQU8sQ0FDTixPQUFPLENBQUUsSUFBSSxDQUFDLElBQUksQ0FDbEIsVUFBVSxDQUFFLElBQUksNkNBQTZDLENBQUMsQ0FDOUQsS0FBSyxDQUFFLElBQUksdUNBQXVDLENBQUMsQ0FDbkQsU0FBUyxDQUFFLEtBQUssQ0FDaEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsTUFBTSxDQUFFLENBQUMsQ0FDVCxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3hDLE1BQU0sQ0FBRSxPQUNULENBQ0EsMENBQWEsQ0FDWixPQUFPLENBQUUsSUFBSSxDQUFDLElBQUksQ0FDbEIsS0FBSyxDQUFFLElBQUksdUNBQXVDLENBQUMsQ0FDbkQsU0FBUyxDQUFFLEtBQUssQ0FDaEIsTUFBTSxDQUFFLE9BQ1QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRGF0ZXBpY2tlci5zdmVsdGUiXX0= */");
}
var get_default_slot_changes6 = (dirty) => ({
  key: dirty & /*key*/
  16384,
  send: dirty & /*send*/
  32768,
  receive: dirty & /*receive*/
  65536,
  formatted: dirty & /*formatted*/
  1
});
var get_default_slot_context6 = (ctx) => ({
  key: (
    /*key*/
    ctx[14]
  ),
  send: (
    /*send*/
    ctx[15]
  ),
  receive: (
    /*receive*/
    ctx[16]
  ),
  formatted: (
    /*formatted*/
    ctx[0]
  )
});
function fallback_block(ctx) {
  let div;
  let button;
  let button_intro;
  let button_outro;
  let t0;
  let span;
  let t1;
  let span_transition;
  let current;
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      t0 = space();
      span = element("span");
      t1 = text(
        /*formatted*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { class: true });
      children(button).forEach(detach_dev);
      t0 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*formatted*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "svelte-18igz6t");
      add_location(button, file11, 42, 4, 1358);
      attr_dev(span, "class", "button-text svelte-18igz6t");
      add_location(span, file11, 43, 4, 1425);
      attr_dev(div, "class", "button-container svelte-18igz6t");
      add_location(div, file11, 41, 3, 1323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t1);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*formatted*/
      1)
        set_data_dev(
          t1,
          /*formatted*/
          ctx[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[16],
            { key: (
              /*key*/
              ctx[14]
            ) }
          );
          button_intro.start();
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, fade, { delay: 150 }, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[15],
          { key: (
            /*key*/
            ctx[14]
          ) }
        );
      }
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, fade, { delay: 150 }, false);
        span_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && button_outro)
        button_outro.end();
      if (detaching && span_transition)
        span_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(41:43)     ",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context6
  );
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, key, send, receive, formatted*/
        118785)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*formatted, key*/
        16385)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(40:1) <Popover {style} let:key let:send let:receive bind:isOpen={$store.open}>",
    ctx
  });
  return block;
}
function create_contents_slot(ctx) {
  let calendar2;
  let current;
  calendar2 = new Calendar_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(calendar2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(calendar2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(calendar2, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendar2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendar2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(calendar2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_contents_slot.name,
    type: "slot",
    source: '(47:2) <svelte:fragment slot=\\"contents\\">',
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let popover;
  let updating_isOpen;
  let current;
  function popover_isOpen_binding(value) {
    ctx[11](value);
  }
  let popover_props = {
    style: (
      /*style*/
      ctx[13]
    ),
    $$slots: {
      contents: [create_contents_slot],
      default: [
        create_default_slot_15,
        ({ key, send, receive }) => ({ 14: key, 15: send, 16: receive }),
        ({ key, send, receive }) => (key ? 16384 : 0) | (send ? 32768 : 0) | (receive ? 65536 : 0)
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*$store*/
    ctx[4].open !== void 0
  ) {
    popover_props.isOpen = /*$store*/
    ctx[4].open;
  }
  popover = new Popover_default({ props: popover_props, $$inline: true });
  binding_callbacks.push(() => bind(popover, "isOpen", popover_isOpen_binding));
  const block = {
    c: function create() {
      create_component(popover.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popover.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const popover_changes = {};
      if (dirty & /*style*/
      8192)
        popover_changes.style = /*style*/
        ctx2[13];
      if (dirty & /*$$scope, formatted, key, send, receive*/
      118785) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_isOpen && dirty & /*$store*/
      16) {
        updating_isOpen = true;
        popover_changes.isOpen = /*$store*/
        ctx2[4].open;
        add_flush_callback(() => updating_isOpen = false);
      }
      popover.$set(popover_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popover, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(39:0) <Theme {defaultTheme} {theme} let:style>",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let theme_1;
  let current;
  theme_1 = new Theme_default({
    props: {
      defaultTheme: (
        /*defaultTheme*/
        ctx[2]
      ),
      theme: (
        /*theme*/
        ctx[1]
      ),
      $$slots: {
        default: [
          create_default_slot6,
          ({ style }) => ({ 13: style }),
          ({ style }) => style ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(theme_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(theme_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(theme_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const theme_1_changes = {};
      if (dirty & /*defaultTheme*/
      4)
        theme_1_changes.defaultTheme = /*defaultTheme*/
        ctx2[2];
      if (dirty & /*theme*/
      2)
        theme_1_changes.theme = /*theme*/
        ctx2[1];
      if (dirty & /*$$scope, style, $store, formatted*/
      12305) {
        theme_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      theme_1.$set(theme_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(theme_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(theme_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(theme_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(4, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Datepicker", slots, ["default"]);
  let { selected = calendar.selected } = $$props;
  let { start = calendar.start } = $$props;
  let { end = calendar.end } = $$props;
  let { format = calendar.format } = $$props;
  let { formatted = "" } = $$props;
  let { theme = {} } = $$props;
  let { defaultTheme = void 0 } = $$props;
  let { startOfWeekIndex = 0 } = $$props;
  let { store = datepicker_default.get({
    selected,
    start,
    end,
    shouldEnlargeDay: true,
    startOfWeekIndex
  }) } = $$props;
  validate_store(store, "store");
  $$subscribe_store();
  setContext(storeContextKey, store);
  setContext(keyControlsContextKey, derived(store, ($s) => $s.activeView));
  const writable_props = [
    "selected",
    "start",
    "end",
    "format",
    "formatted",
    "theme",
    "defaultTheme",
    "startOfWeekIndex",
    "store"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Datepicker> was created with unknown prop '${key}'`);
  });
  function popover_isOpen_binding(value) {
    if ($$self.$$.not_equal($store.open, value)) {
      $store.open = value;
      store.set($store);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("start" in $$props2)
      $$invalidate(6, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(7, end = $$props2.end);
    if ("format" in $$props2)
      $$invalidate(8, format = $$props2.format);
    if ("formatted" in $$props2)
      $$invalidate(0, formatted = $$props2.formatted);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("defaultTheme" in $$props2)
      $$invalidate(2, defaultTheme = $$props2.defaultTheme);
    if ("startOfWeekIndex" in $$props2)
      $$invalidate(9, startOfWeekIndex = $$props2.startOfWeekIndex);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(3, store = $$props2.store));
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    dayjs: import_dayjs6.default,
    datepickerStore: datepicker_default,
    keyControlsContextKey,
    storeContextKey,
    setContext,
    derived,
    Popover: Popover_default,
    Theme: Theme_default,
    Calendar: Calendar_default,
    fade,
    calendarDefaults: calendar,
    selected,
    start,
    end,
    format,
    formatted,
    theme,
    defaultTheme,
    startOfWeekIndex,
    store,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(5, selected = $$props2.selected);
    if ("start" in $$props2)
      $$invalidate(6, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(7, end = $$props2.end);
    if ("format" in $$props2)
      $$invalidate(8, format = $$props2.format);
    if ("formatted" in $$props2)
      $$invalidate(0, formatted = $$props2.formatted);
    if ("theme" in $$props2)
      $$invalidate(1, theme = $$props2.theme);
    if ("defaultTheme" in $$props2)
      $$invalidate(2, defaultTheme = $$props2.defaultTheme);
    if ("startOfWeekIndex" in $$props2)
      $$invalidate(9, startOfWeekIndex = $$props2.startOfWeekIndex);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(3, store = $$props2.store));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$store*/
    16) {
      $:
        $$invalidate(5, selected = $store.selected);
    }
    if ($$self.$$.dirty & /*selected, format*/
    288) {
      $:
        $$invalidate(0, formatted = (0, import_dayjs6.default)(selected).format(format));
    }
  };
  return [
    formatted,
    theme,
    defaultTheme,
    store,
    $store,
    selected,
    start,
    end,
    format,
    startOfWeekIndex,
    slots,
    popover_isOpen_binding,
    $$scope
  ];
}
var Datepicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        selected: 5,
        start: 6,
        end: 7,
        format: 8,
        formatted: 0,
        theme: 1,
        defaultTheme: 2,
        startOfWeekIndex: 9,
        store: 3
      },
      add_css10
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Datepicker",
      options,
      id: create_fragment15.name
    });
  }
  get selected() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatted() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatted(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultTheme() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultTheme(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startOfWeekIndex() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startOfWeekIndex(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get store() {
    throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set store(value) {
    throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Datepicker_default = Datepicker;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/InlineCalendar.svelte
var import_dayjs7 = __toESM(require_dayjs_min());

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/crossfade/CrossfadeBoundary.svelte
function create_fragment16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CrossfadeBoundary", slots, ["default"]);
  setContext("crossfade", null);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CrossfadeBoundary> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$scope, slots];
}
var CrossfadeBoundary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CrossfadeBoundary",
      options,
      id: create_fragment16.name
    });
  }
};
var CrossfadeBoundary_default = CrossfadeBoundary;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/InlineCalendar.svelte
var file12 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\InlineCalendar.svelte";
function add_css11(target) {
  append_styles(target, "svelte-1g1k4nu", "div.svelte-1g1k4nu{display:inline-block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5saW5lQ2FsZW5kYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWtEQyxrQkFBSSxDQUNILE9BQU8sQ0FBRSxZQUNWIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIklubGluZUNhbGVuZGFyLnN2ZWx0ZSJdfQ== */");
}
function create_default_slot_16(ctx) {
  let div;
  let calendar2;
  let div_style_value;
  let current;
  let mounted;
  let dispose;
  calendar2 = new Calendar_default({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(calendar2.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true, class: true });
      var div_nodes = children(div);
      claim_component(calendar2.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "style", div_style_value = /*style*/
      ctx[12]);
      attr_dev(div, "class", "svelte-1g1k4nu");
      add_location(div, file12, 37, 2, 1326);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(calendar2, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "focus",
            /*getFocusSetter*/
            ctx[3](true),
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "blur",
            /*getFocusSetter*/
            ctx[3](false),
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseover",
            /*getFocusSetter*/
            ctx[3](true),
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseout",
            /*getFocusSetter*/
            ctx[3](false),
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*style*/
      4096 && div_style_value !== (div_style_value = /*style*/
      ctx2[12])) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(calendar2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(calendar2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(calendar2);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(37:1) <Theme {defaultTheme} {theme} let:style>",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let theme_1;
  let current;
  theme_1 = new Theme_default({
    props: {
      defaultTheme: (
        /*defaultTheme*/
        ctx[1]
      ),
      theme: (
        /*theme*/
        ctx[0]
      ),
      $$slots: {
        default: [
          create_default_slot_16,
          ({ style }) => ({ 12: style }),
          ({ style }) => style ? 4096 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(theme_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(theme_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(theme_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const theme_1_changes = {};
      if (dirty & /*defaultTheme*/
      2)
        theme_1_changes.defaultTheme = /*defaultTheme*/
        ctx2[1];
      if (dirty & /*theme*/
      1)
        theme_1_changes.theme = /*theme*/
        ctx2[0];
      if (dirty & /*$$scope, style*/
      12288) {
        theme_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      theme_1.$set(theme_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(theme_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(theme_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(theme_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(36:0) <CrossfadeBoundary>",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let crossfadeboundary;
  let current;
  crossfadeboundary = new CrossfadeBoundary_default({
    props: {
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(crossfadeboundary.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(crossfadeboundary.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(crossfadeboundary, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const crossfadeboundary_changes = {};
      if (dirty & /*$$scope, defaultTheme, theme*/
      8195) {
        crossfadeboundary_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crossfadeboundary.$set(crossfadeboundary_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(crossfadeboundary.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(crossfadeboundary.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(crossfadeboundary, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, ($$value) => $$invalidate(10, $store = $$value)), store);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineCalendar", slots, []);
  let { selected = calendar.selected } = $$props;
  let { start = calendar.start } = $$props;
  let { end = calendar.end } = $$props;
  let { format = calendar.format } = $$props;
  let { formatted = "" } = $$props;
  let { theme = {} } = $$props;
  let { defaultTheme = void 0 } = $$props;
  let { startOfWeekIndex = 0 } = $$props;
  let { store = datepicker_default.get({ selected, start, end, startOfWeekIndex }) } = $$props;
  validate_store(store, "store");
  $$subscribe_store();
  const focused = writable(false);
  setContext(storeContextKey, store);
  setContext(keyControlsContextKey, derived([store, focused], ([$s, $focused]) => $focused ? $s.activeView : void 0));
  const getFocusSetter = (bool) => () => focused.set(bool);
  const writable_props = [
    "selected",
    "start",
    "end",
    "format",
    "formatted",
    "theme",
    "defaultTheme",
    "startOfWeekIndex",
    "store"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InlineCalendar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(4, selected = $$props2.selected);
    if ("start" in $$props2)
      $$invalidate(6, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(7, end = $$props2.end);
    if ("format" in $$props2)
      $$invalidate(8, format = $$props2.format);
    if ("formatted" in $$props2)
      $$invalidate(5, formatted = $$props2.formatted);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("defaultTheme" in $$props2)
      $$invalidate(1, defaultTheme = $$props2.defaultTheme);
    if ("startOfWeekIndex" in $$props2)
      $$invalidate(9, startOfWeekIndex = $$props2.startOfWeekIndex);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(2, store = $$props2.store));
  };
  $$self.$capture_state = () => ({
    dayjs: import_dayjs7.default,
    datepickerStore: datepicker_default,
    keyControlsContextKey,
    storeContextKey,
    setContext,
    derived,
    writable,
    Theme: Theme_default,
    Calendar: Calendar_default,
    CrossfadeBoundary: CrossfadeBoundary_default,
    calendarDefaults: calendar,
    selected,
    start,
    end,
    format,
    formatted,
    theme,
    defaultTheme,
    startOfWeekIndex,
    store,
    focused,
    getFocusSetter,
    $store
  });
  $$self.$inject_state = ($$props2) => {
    if ("selected" in $$props2)
      $$invalidate(4, selected = $$props2.selected);
    if ("start" in $$props2)
      $$invalidate(6, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(7, end = $$props2.end);
    if ("format" in $$props2)
      $$invalidate(8, format = $$props2.format);
    if ("formatted" in $$props2)
      $$invalidate(5, formatted = $$props2.formatted);
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("defaultTheme" in $$props2)
      $$invalidate(1, defaultTheme = $$props2.defaultTheme);
    if ("startOfWeekIndex" in $$props2)
      $$invalidate(9, startOfWeekIndex = $$props2.startOfWeekIndex);
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(2, store = $$props2.store));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$store*/
    1024) {
      $:
        $$invalidate(4, selected = $store.selected);
    }
    if ($$self.$$.dirty & /*selected, format*/
    272) {
      $:
        $$invalidate(5, formatted = (0, import_dayjs7.default)(selected).format(format));
    }
  };
  return [
    theme,
    defaultTheme,
    store,
    getFocusSetter,
    selected,
    formatted,
    start,
    end,
    format,
    startOfWeekIndex,
    $store
  ];
}
var InlineCalendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        selected: 4,
        start: 6,
        end: 7,
        format: 8,
        formatted: 5,
        theme: 0,
        defaultTheme: 1,
        startOfWeekIndex: 9,
        store: 2
      },
      add_css11
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineCalendar",
      options,
      id: create_fragment17.name
    });
  }
  get selected() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatted() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatted(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultTheme() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultTheme(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startOfWeekIndex() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set startOfWeekIndex(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get store() {
    throw new Error("<InlineCalendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set store(value) {
    throw new Error("<InlineCalendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InlineCalendar_default = InlineCalendar;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/Swappable.svelte
var file13 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\generic\\Swappable.svelte";
function add_css12(target) {
  append_styles(target, "svelte-11eiuvz", ".grid.svelte-11eiuvz{display:grid;grid-template:1fr / 1fr;overflow:hidden}.cell.svelte-11eiuvz{display:grid;grid-column:1;grid-row:1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3dhcHBhYmxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFxRUMsb0JBQU0sQ0FDTCxPQUFPLENBQUUsSUFBSSxDQUNiLGFBQWEsQ0FBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FDeEIsUUFBUSxDQUFFLE1BQ1gsQ0FDQSxvQkFBTSxDQUNMLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLENBQUMsQ0FDZCxRQUFRLENBQUUsQ0FDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTd2FwcGFibGUuc3ZlbHRlIl19 */");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i].value;
  child_ctx[18] = list[i].id;
  return child_ctx;
}
var get_default_slot_changes7 = (dirty) => ({ value: dirty & /*arr*/
8 });
var get_default_slot_context7 = (ctx) => ({ value: (
  /*value*/
  ctx[0]
) });
function create_each_block5(key_1, ctx) {
  let div;
  let t;
  let div_resize_listener;
  let div_intro;
  let div_outro;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context7
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "cell svelte-11eiuvz");
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[14].call(div)
      ));
      add_location(div, file13, 56, 2, 1258);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[14].bind(div)
      );
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, arr*/
        4104)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[12],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(
            div,
            fly,
            /*inOptions*/
            ctx[4]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          fly,
          /*outOptions*/
          ctx[5]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      div_resize_listener();
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(56:1) {#each arr as { value, id }",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like_dev(
    /*arr*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*id*/
    ctx2[18]
  );
  validate_each_keys(ctx, each_value, get_each_context5, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "grid svelte-11eiuvz");
      add_location(div, file13, 54, 0, 1202);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*width, height, outOptions, $$scope, arr*/
      4142) {
        each_value = ensure_array_like_dev(
          /*arr*/
          ctx2[3]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context5, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block5, null, get_each_context5);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let xMult;
  let yMult;
  let inOptions;
  let outOptions;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Swappable", slots, ["default"]);
  let { value } = $$props;
  let { getId = (value2) => (value2 == null ? void 0 : value2.id) || value2 } = $$props;
  let { vertical = true } = $$props;
  let { magnitude = 1 } = $$props;
  let { opacity = 1 } = $$props;
  let { delay = 1 } = $$props;
  let height;
  let width;
  let arr;
  let dir;
  const replaceArr = async (newArr) => {
    await tick();
    $$invalidate(3, arr = newArr);
  };
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Swappable> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value", "getId", "vertical", "magnitude", "opacity", "delay"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Swappable> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    width = this.clientWidth;
    height = this.clientHeight;
    $$invalidate(2, width);
    $$invalidate(1, height);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("getId" in $$props2)
      $$invalidate(6, getId = $$props2.getId);
    if ("vertical" in $$props2)
      $$invalidate(7, vertical = $$props2.vertical);
    if ("magnitude" in $$props2)
      $$invalidate(8, magnitude = $$props2.magnitude);
    if ("opacity" in $$props2)
      $$invalidate(9, opacity = $$props2.opacity);
    if ("delay" in $$props2)
      $$invalidate(10, delay = $$props2.delay);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    tick,
    quintOut,
    fly,
    fade,
    value,
    getId,
    vertical,
    magnitude,
    opacity,
    delay,
    height,
    width,
    arr,
    dir,
    replaceArr,
    inOptions,
    outOptions,
    yMult,
    xMult
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("getId" in $$props2)
      $$invalidate(6, getId = $$props2.getId);
    if ("vertical" in $$props2)
      $$invalidate(7, vertical = $$props2.vertical);
    if ("magnitude" in $$props2)
      $$invalidate(8, magnitude = $$props2.magnitude);
    if ("opacity" in $$props2)
      $$invalidate(9, opacity = $$props2.opacity);
    if ("delay" in $$props2)
      $$invalidate(10, delay = $$props2.delay);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("arr" in $$props2)
      $$invalidate(3, arr = $$props2.arr);
    if ("dir" in $$props2)
      $$invalidate(11, dir = $$props2.dir);
    if ("inOptions" in $$props2)
      $$invalidate(4, inOptions = $$props2.inOptions);
    if ("outOptions" in $$props2)
      $$invalidate(5, outOptions = $$props2.outOptions);
    if ("yMult" in $$props2)
      yMult = $$props2.yMult;
    if ("xMult" in $$props2)
      xMult = $$props2.xMult;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*vertical*/
    128) {
      $:
        xMult = vertical ? 0 : 1;
    }
    if ($$self.$$.dirty & /*vertical*/
    128) {
      $:
        yMult = vertical ? 1 : 0;
    }
    if ($$self.$$.dirty & /*arr, value, getId*/
    73) {
      $: {
        if ((arr == null ? void 0 : arr[0].value) !== value) {
          const id = getId(value);
          $$invalidate(11, dir = !arr ? 1 : arr[0].id > id ? -1 : 1);
          const newArr = [{ value, id }];
          if (arr) {
            replaceArr(newArr);
          } else {
            $$invalidate(3, arr = newArr);
          }
        }
      }
    }
    if ($$self.$$.dirty & /*opacity, delay, vertical, magnitude, dir, height, width*/
    3974) {
      $:
        $$invalidate(4, inOptions = {
          duration: 650,
          opacity,
          easing: quintOut,
          delay,
          ...vertical ? { y: magnitude * dir * height } : { x: magnitude * dir * width }
        });
    }
    if ($$self.$$.dirty & /*inOptions, vertical, magnitude, dir, height, width*/
    2454) {
      $:
        $$invalidate(5, outOptions = {
          ...inOptions,
          ...vertical ? { y: -1 * magnitude * dir * height } : { x: -1 * magnitude * dir * width }
        });
    }
  };
  return [
    value,
    height,
    width,
    arr,
    inOptions,
    outOptions,
    getId,
    vertical,
    magnitude,
    opacity,
    delay,
    dir,
    $$scope,
    slots,
    div_elementresize_handler
  ];
}
var Swappable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance18,
      create_fragment18,
      safe_not_equal,
      {
        value: 0,
        getId: 6,
        vertical: 7,
        magnitude: 8,
        opacity: 9,
        delay: 10
      },
      add_css12
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Swappable",
      options,
      id: create_fragment18.name
    });
  }
  get value() {
    throw new Error("<Swappable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Swappable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getId() {
    throw new Error("<Swappable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getId(value) {
    throw new Error("<Swappable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<Swappable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<Swappable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get magnitude() {
    throw new Error("<Swappable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set magnitude(value) {
    throw new Error("<Swappable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Swappable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Swappable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Swappable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<Swappable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Swappable_default = Swappable;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/Scrollable.svelte
var file14 = "C:\\Users\\DELL\\Desktop\\classroomio\\classroomio\\node_modules\\.pnpm\\svelte-calendar@3.1.6\\node_modules\\svelte-calendar\\components\\generic\\Scrollable.svelte";
function add_css13(target) {
  append_styles(target, "svelte-y104lg", "div.svelte-y104lg{height:100%;display:grid;overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2Nyb2xsYWJsZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdUJDLGlCQUFJLENBQ0gsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxNQUNYIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNjcm9sbGFibGUuc3ZlbHRlIl19 */");
}
function create_fragment19(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-y104lg");
      add_location(div, file14, 14, 0, 323);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div,
            "wheel",
            /*wheel*/
            ctx[1],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "touchstart", stop_propagation(
            /*touchstart*/
            ctx[2]
          ), false, false, true, false),
          listen_dev(div, "touchmove", stop_propagation(
            /*touchmove*/
            ctx[3]
          ), false, false, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let $last;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Scrollable", slots, ["default"]);
  let { y = 0 } = $$props;
  const last = writable(0);
  validate_store(last, "last");
  component_subscribe($$self, last, (value) => $$invalidate(7, $last = value));
  const wheel = (evt) => $$invalidate(4, y += evt.deltaY);
  const touchstart = ({ touches }) => last.set(touches[0].pageY);
  const touchmove = ({ touches }) => {
    $$invalidate(4, y -= touches[0].pageY - $last);
    last.set(touches[0].pageY);
  };
  const writable_props = ["y"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Scrollable> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(4, y = $$props2.y);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    y,
    last,
    wheel,
    touchstart,
    touchmove,
    $last
  });
  $$self.$inject_state = ($$props2) => {
    if ("y" in $$props2)
      $$invalidate(4, y = $$props2.y);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [last, wheel, touchstart, touchmove, y, $$scope, slots];
}
var Scrollable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { y: 4 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Scrollable",
      options,
      id: create_fragment19.name
    });
  }
  get y() {
    throw new Error("<Scrollable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Scrollable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Scrollable_default = Scrollable;

// ../../node_modules/.pnpm/svelte-calendar@3.1.6/node_modules/svelte-calendar/components/generic/FiniteGrid.svelte
var get_default_slot_changes8 = (dirty) => ({ value: dirty & /*value*/
2 });
var get_default_slot_context8 = (ctx) => ({ value: (
  /*value*/
  ctx[1]
) });
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, value*/
        66)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(15:0) <InfiniteGrid {cellCount} {itemCount} {index} {get} let:value>",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let infinitegrid;
  let current;
  infinitegrid = new InfiniteGrid_default({
    props: {
      cellCount,
      itemCount: (
        /*itemCount*/
        ctx[2]
      ),
      index: (
        /*index*/
        ctx[0]
      ),
      get: (
        /*get*/
        ctx[3]
      ),
      $$slots: {
        default: [
          create_default_slot8,
          ({ value }) => ({ 1: value }),
          ({ value }) => value ? 2 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(infinitegrid.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(infinitegrid.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(infinitegrid, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const infinitegrid_changes = {};
      if (dirty & /*itemCount*/
      4)
        infinitegrid_changes.itemCount = /*itemCount*/
        ctx2[2];
      if (dirty & /*index*/
      1)
        infinitegrid_changes.index = /*index*/
        ctx2[0];
      if (dirty & /*$$scope, value*/
      66) {
        infinitegrid_changes.$$scope = { dirty, ctx: ctx2 };
      }
      infinitegrid.$set(infinitegrid_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(infinitegrid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(infinitegrid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(infinitegrid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cellCount = 1;
function instance20($$self, $$props, $$invalidate) {
  let itemCount;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FiniteGrid", slots, ["default"]);
  let { value } = $$props;
  let { values } = $$props;
  let { index = 0 } = $$props;
  const get2 = (i) => ({ value: values[i] });
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<FiniteGrid> was created without expected prop 'value'");
    }
    if (values === void 0 && !("values" in $$props || $$self.$$.bound[$$self.$$.props["values"]])) {
      console.warn("<FiniteGrid> was created without expected prop 'values'");
    }
  });
  const writable_props = ["value", "values", "index"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FiniteGrid> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("values" in $$props2)
      $$invalidate(4, values = $$props2.values);
    if ("index" in $$props2)
      $$invalidate(0, index = $$props2.index);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    InfiniteGrid: InfiniteGrid_default,
    value,
    values,
    index,
    cellCount,
    get: get2,
    itemCount
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("values" in $$props2)
      $$invalidate(4, values = $$props2.values);
    if ("index" in $$props2)
      $$invalidate(0, index = $$props2.index);
    if ("itemCount" in $$props2)
      $$invalidate(2, itemCount = $$props2.itemCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*values*/
    16) {
      $:
        $$invalidate(2, itemCount = values.length);
    }
    if ($$self.$$.dirty & /*values, value*/
    18) {
      $:
        $$invalidate(0, index = values.indexOf(value));
    }
  };
  return [index, value, itemCount, get2, values, slots, $$scope];
}
var FiniteGrid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { value: 1, values: 4, index: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FiniteGrid",
      options,
      id: create_fragment20.name
    });
  }
  get value() {
    throw new Error("<FiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<FiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get values() {
    throw new Error("<FiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set values(value) {
    throw new Error("<FiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get index() {
    throw new Error("<FiniteGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<FiniteGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FiniteGrid_default = FiniteGrid;
export {
  Calendar_default as Calendar,
  Crossfade_default as Crossfade,
  CrossfadeProvider_default as CrossfadeProvider,
  Datepicker_default as Datepicker,
  FiniteGrid_default as FiniteGrid,
  InfiniteGrid_default as InfiniteGrid,
  InlineCalendar_default as InlineCalendar,
  Popover_default as Popover,
  Scrollable_default as Scrollable,
  Swappable_default as Swappable,
  Theme_default as Theme,
  scrollable_default as scrollable,
  theme_exports as themes
};
//# sourceMappingURL=svelte-calendar.js.map
